---
title: "Analysis of the trajectories of the harvesters using HMM"
output:
  pdf_document: default
bibliography: movehmm.bib
---

In this document I will present some results and interpretations of the analysis of the spatial trajectories of the harvesters using Hidden Markov Models (HMM).

## 0. Introduction to HMM 

Hidden Markov models (HMMs) are models in which the distribution that generates an observation $Z_t$ depends on the state $S_t$ of an underlying and unobserved Markov process (that satisfies the Markov property; Figure 1). In the context of animal movement, the state $S_t$ is interpreted as a proxy for the behavioral state of the animal (e.g. foraging, exploring). The observations $Zt$ are bivariate time series ($Zt = (l_t, \phi_t)$) where $l_t$ is the step length (the Euclidean distance) and $\phi_t$ the turning angle, between two succesive locations [@michelot2019movehmm, @zucchini2016hidden]. Biologically speaking, these models try to include the process where the movement of agents (e.g. short or large steps) depends on its behavior. With these models, we can define the most likely sequence of states along the trajectory of an agent, its average time within a state, and the number of switches between states.  

![Representation of the HMM. taken from (Michelot, Langrock and Patterson, 2019)](hmmfigure.png){width=50%}

Here we used the _movehmm_ library (@michelot2019movehmm) to i) fit the most likely HMM to the harvester movement data and ii) describe the different states, the sequence of states and the difference between farms. 

## 1. Fitting of HMM

### 1.1. Preparation of data

We loaded _ggplot2_, _dplyr_, _tidyverse_ and _movehmm_ libraries. We then loaded the data of the trajectories and did some punctual modifications to it. We had in total 12 trajectories, with ($x, y$) coordinates (Fig. 2).

```{r, message=FALSE, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(moveHMM)
library(knitr)
library(reshape2)
colorsGris <- c("black","#555555", "white")
groupColors3 <- c("#021128", "#fd9706", "#1b4a64" )
groupColors2 <- c("#021128", "#fd9706")
mycols3c <-c("#759580", "#1b4a64")
```


```{r, echo=FALSE, message=FALSE}
WP_COSECHA_UTM_SP <- read.csv("../data/cleanData_wayPointsCoffee_UTM.csv", stringsAsFactors = FALSE )

WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  mutate(finca = replace(finca, finca == "Irlanda", "I")) %>%
  mutate(finca = replace(finca, finca == "Hamburgo", "H"))

WP_COSECHA_UTM_SP$zona[WP_COSECHA_UTM_SP$zona == "falta"] <- "zonaBaja"
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>% rowwise() %>% 
  group_by(ID_REC, pante)%>%  #esto debe seguirse con lo de aajo
  mutate(xNorm = x_UTM - min(x_UTM)) %>%
  mutate(yNorm = y_UTM - min(y_UTM))

#now the precision (not the accuracy) of the GPS goes to 5 decimal points (lat y lot) and this is equivalent to ~1m
#so we can round the xNorm and y yNorm

WP_COSECHA_UTM_SP$xNorm <- round(WP_COSECHA_UTM_SP$xNorm, 0)
WP_COSECHA_UTM_SP$yNorm <- round(WP_COSECHA_UTM_SP$yNorm, 0)

#we remove some spurious data were delta = 0
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  filter(delta !=0)%>%
  unite("Finca_ID_REC", finca, ID_REC, remove = FALSE)

#we create this ID column to prepare the data for movehmm
WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP %>%
  dplyr::select("ID" = Finca_ID_REC, xNorm, yNorm)

WP_COSECHA_UTM_SP_PRE$pante <- NULL
WP_COSECHA_UTM_SP_PRE$ID_REC <- NULL
```

```{r echo=FALSE, warning=FALSE, fig.cap= "12 trajectories of harvesters. The green line represent the Farm Hamburgo (H) and the blue line the Farm Irlanda (I)." , fig.height= 12, fig.width=10}
mapHarvest_total<- WP_COSECHA_UTM_SP_PRE %>% 
  separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>% 
  ggplot(aes(x= xNorm, y = yNorm)) +
  geom_path(aes(col= Finca), size= 1)+
  geom_point(size=1)+ # es importante que sea path, porque así lo hace según coo estan ordenados los
  scale_color_manual(values= mycols3c)+
  facet_wrap(~ ID, ncol=3)+
  theme(panel.spacing = unit(0.8, "lines"), text = element_text(size = 15))+
  theme_bw()+
  labs(x= "X_norm", y= "Y_norm", col= "Farm")

#ggsave("../output/mapHarvest_I.png", height = 8, width = 12, device = "png")

mapHarvest_total
```
```{r, echo=FALSE}
dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros

summary(dataCosecha)
```

A first assumption for the analysis was made: we took these time irregular trajectories (where each point represents one different tree, but where the time between two trees is variable) and treated them as a regular trajectories. This aimed to analyze the change in the movement of the workers during a day, generated by the underlying pattern of trees or by the differences in the fruit charge and ripening synchronicity. We convert this database into a movehmm object where the step distance $l_t$ and the relative angle $\phi_t$ between the $(x, y)$ coordinates is calculated (table 1). We plotted the histograms of both the steps and the angles (Fig. 3 and Fig. 4). 


```{r echo=FALSE} 
kable(head(dataCosecha), caption = "First lines of the movehmm object")
```



```{r echo=FALSE, fig.cap= "Histogram of the steps lengths per farm", warning=FALSE, fig.height= 4, fig.width=8}
pHisto_step <-dataCosecha %>%
separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>%
  ggplot(aes(x= as.numeric(step), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=2, color= "black", aes(fill=as.character(Finca))) +
scale_fill_manual(values= mycols3c)+  
facet_wrap(~Finca)+
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Distance (in m)", y= "Proportion", fill= "Farm")
pHisto_step
```

```{r echo=FALSE, fig.cap= "Radial histogram of the relative angles, per farm",  warning=FALSE, fig.height= 4, fig.width=8}
pHisto_angle <-dataCosecha %>%
separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>%
  ggplot(aes(x= as.numeric(angle), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=0.5, color= "black", aes(fill=as.character(Finca))) +
    coord_polar(theta="x", start=pi/2, direction=-1)+
scale_fill_manual(values= mycols3c)+  
facet_wrap(~Finca)+
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Angle (in radians)", y= "Proportion", fill= "Farm")
pHisto_angle
```

Now, for the following analysis, we only took the step distance and treated both farms as one. We decided to exclude the angles because they didn't have a biological meaning for irregular trajectories. The input for the analysis is then the histogram presented in Fig. 5. 


```{r echo=FALSE, warning=FALSE, fig.cap= "Histogram of the steps lengths", fig.height= 6, fig.width=10}
pHisto_step_general <-dataCosecha %>%
  ggplot(aes(x= as.numeric(step), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=2, color= "black", aes(fill=as.character(ID))) +
scale_fill_viridis_d()+  
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Distance (in m)", y= "Proportion", fill= "ID")
pHisto_step_general
```


### 1.2. Fitting of the data


The algorithm of the _movehmm_ library uses:

a) a predefined number of states. Here we will use two. 

b) a defined family of distributions. Here we will try to fit two different exponential families (_gamma_ and _weibull_).

c) prior parameters for each of the distributions, for each state. 

d) The observations (step-lengths) (the data of harvesters)

With these inputs, the algorithm extracts the most likely two-state-distributions with their respective parameters (within the predefined family of distributions) that fit the data and the most likely sequence of states (assuming a markov process). During the fitting process, the algorithm uses the maximum-log likelihood and the _forward algorithm_ (a recursive algorithm starting with the prior distributions; [@zucchini2016hidden]).

We ran a loop to fit the two different families (_weibull_, and _gamma_) and in order to avoid local maximal likelihoods, we swapped 1000 combinations across a range of prior parameters for each model [@michelot2019movehmm]. For the _gamma_ distribution, the minimum and maximum values of each range were chosen to encompass the full distribution. For the _weibull_ distribution, the maximum shape considered the left-skew shape and the scale was chosen to include the 120m long steps (see ranges in table 2). It is important to note that these are only priors guesses, and the real parameters can outbound these limits. Many of these combinations of prior parameters converged to the same final distributions.  

```{r, echo=FALSE}
rangosDist <- list("gamma" = list("mean" = c(0.1, 20), "sd" = c(0.1,20)), 
                   "weibull" = list("shape" = c(0, 2.7), "scale" = c(0.1,15))  ##segun el articulo
                   )

DF_rangos <- data.frame("value" = c("min", "max"))
DF_rangos <- cbind(DF_rangos, as.data.frame(rangosDist))
kable(DF_rangos, caption = "Minimun and maximum values of the prior parameters for each distribution")
```


```{r, echo=FALSE}
DF_TOTAL <- data.frame("model"= 0, 
            "prior_par0_st1_st2"= 0,
            "prior_par1_st1_st2" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0,
           "st2_par0"=0,
           "st2_par1"= 0)

repetitions <- seq(1, 1000,1)
runModel <- "no"
if (runModel == "yes"){
for (modelStep in c("weibull", "gamma")){
  print(modelStep)
  rangePar0 <- runif(100000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])
  rangePar1 <- runif(100000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2])
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE),
              sample(rangePar0,1, replace= TRUE)) # step mean (two parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE), 
              sample(rangePar1,1, replace= TRUE)) 
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 2 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha$mod$minimum
    AIC_model <- AIC(m_cosecha)
    
    DF_TEMP <- data.frame("model"= modelStep, 
                          "prior_par0_st1_st2"= paste(par0[1], "_", par0[2]), 
                          "prior_par1_st1_st2"=  paste(par1[1], "_", par1[2]),
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha$mle$stepPar[1,1],
                          "st1_par1"= m_cosecha$mle$stepPar[2,1],
                          "st2_par0"= m_cosecha$mle$stepPar[1,2],
                          "st2_par1"= m_cosecha$mle$stepPar[2,2])
    
                      
    DF_TOTAL <- rbind(DF_TOTAL, DF_TEMP)    
    
    
      }
}

DF_TOTAL <- DF_TOTAL%>%
  filter(model != 0)
}
#write_csv(DF_TOTAL, "../output/wholeTable_1000_rep_0_20.csv")
```


```{r, echo=FALSE}
DF_TOTAL_1000 <- read.csv("../output/wholeTable_1000_rep_0_20.csv")


DF_TOTAL_1000 <- DF_TOTAL_1000 %>%
  filter(model != "lnorm") %>%
  separate(prior_par0_st1_st2, c("pr_par0_st1", "pr_par0_st2"), sep= "_", remove = TRUE) %>%
  separate(prior_par1_st1_st2, c("pr_par1_st1", "pr_par1_st2"), sep= "_", remove = TRUE)

DF_TOTAL_1000$pr_par0_st1 <- as.numeric(DF_TOTAL_1000$pr_par0_st1)
DF_TOTAL_1000$pr_par1_st1 <- as.numeric(DF_TOTAL_1000$pr_par1_st1)
DF_TOTAL_1000$pr_par0_st2 <- as.numeric(DF_TOTAL_1000$pr_par0_st2)
DF_TOTAL_1000$pr_par1_st2 <- as.numeric(DF_TOTAL_1000$pr_par1_st2)

DF_TOTAL_1000[,seq(2,11,1)] <- round(DF_TOTAL_1000[,seq(2,11,1)], 2)

```

For each combination of parameters we registered the final parameters and the minimum negative log-likelihood. The minimum negative log-likelihood is equivalent to the maximum likelihood. 

\newpage

## 2. Description of the states, for each studied distribution.

Some combinations resulted in distributions with zero variance. We decided to remove those cases as they did not make any biological sense. We then plotted the min negative log of the likelihood without these outliers (Fig. 6). We note that almost all the combinations of prior parameters converge to two minimum likelihoods. We chose, for each family of distributions the model that had the minimum AIC value (table 3). 

```{r, echo=FALSE}
#here we have the outiers that were removed
DF_1000_OUTLIERS <- DF_TOTAL_1000 %>%
  filter(st1_par1 <0.00001 | st2_par1 <0.00001)

DF_1000_OUTLIERS <- DF_1000_OUTLIERS %>%
  group_by(model) %>%
  mutate(conteo = 1)%>%
  mutate(contador = cumsum(conteo))
```

```{r, echo=FALSE}
DF_1000_SIN <- DF_TOTAL_1000 %>%
  filter(st1_par1 >0.00001 & st2_par1 >0.00001)
```


```{r, fig.cap= "Minimun Negative Log-likelihood per combination of prior parameters for two different distributions", echo=FALSE, fig.height= 3, fig.width=5}
FIG_AIC_model <- DF_1000_SIN %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot()+
  geom_jitter(aes(x= model, y= minNegLike, shape= model, fill= model), size= 4)+
  scale_fill_manual(values = c("#AAAAAA", "#FFFFFF")) +
  #scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_AIC_model
```



```{r, echo=FALSE}
DF_TOTAL_MIN <- DF_1000_SIN %>%
  group_by(model)%>%
  filter(AIC_model == min(AIC_model)) %>%
  group_by(model, AIC_model) %>%
  mutate(conteo = 1)%>%
  mutate(contador= cumsum(conteo))%>%
  filter(contador ==1)

DF_TOTAL_MIN$conteo <- NULL
DF_TOTAL_MIN$contador <- NULL

DF_TOTAL_MIN_SHOW <- DF_TOTAL_MIN

names(DF_TOTAL_MIN_SHOW) <- (c("model","pr_st1_p1", "pr_st1_p2", "pr_st2_p1", "pr_st2_p2", "minNegL", "AIC", "s1_p1", "s1_p2", "s2_p2", "s2_p2"))


kable(DF_TOTAL_MIN_SHOW, caption = "Best models for each of the distributions. pr:prior, st1: state 1, p1: parameter 1 (shape for weibull and mean for gamma, p2: parameter 2 (scale for weibull and sd for gamma).")
```

We plotted the two state distributions for _gamma_ and for _weibull_ families (see figure. 7 and table 4 for the final parameters). For both families, one of the states produced a distribution that encompass all highly frequent short steps and falls abruptly for size steps bigger than 13 m. The other state generates a long tailed distribution with a lower probability of short steps (compared to the other distribution) and a non zero probability for steps bigger than 13 m (Fig. 7 and table 4).


```{r echo=FALSE}
finalParameters <- read.csv("./tableParameters.csv")
finalParameters[,2] <- round(finalParameters[,2],2)
finalParameters[,3] <- round(finalParameters[,3],2)

kable(finalParameters, caption = "Final parameters for both gamma and weibull distributions. For the gamma distribution $\\alpha = \\mu/\\sigma^2$; $\\beta = \\mu^2/\\sigma^2$; $\\theta = 1/\\beta$.")

```



```{r echo=FALSE}

X= seq(1, 120, 1)

DF_weibull_st1 <- data.frame("distribution"= c("weibull"), "state" = 1, "X"= X,  "PDF" = dweibull(X, shape= 2.05, scale= 4.71))

DF_weibull_st2 <- data.frame("distribution"= c("weibull"), "state" = 2, "X"= X,  "PDF" = dweibull(X, shape= 1.05, scale= 14.45))

DF_gamma_st1 <- data.frame("distribution"= c("gamma"), "state" = 1, "X"= X,  "PDF" = dgamma(X, shape= 1.3, rate = 0.075))

DF_gamma_st2 <- data.frame("distribution"= c("gamma"), "state" = 2, "X"= X,  "PDF" = dgamma(X, shape= 3.62, rate = 0.845))


DF_DISTRI <- rbind(DF_weibull_st1, DF_weibull_st2, DF_gamma_st1, DF_gamma_st2)
```


```{r echo=FALSE, warning=FALSE, fig.cap= "Two state model distributions. The used parameters are shown in Table 4", fig.height= 5, fig.width=10}

DIS_PLOT<- ggplot() +
  geom_histogram(data= dataCosecha, size= 0.2, aes(x= as.numeric(step), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..]), binwidth=2, color= "white", fill= "#CCCCCC") +
geom_line(data = DF_DISTRI, size= 1, aes(x= X, y= PDF, col= as.factor(state)))+
  facet_grid(~ distribution, scales = "free_y")+
  scale_color_manual(values = 
                    groupColors2)+
  theme_bw()+
   labs(x= "Step size (in m)", y= "Probability Density Function", col= "State")

DIS_PLOT

```

This results makes sense with our intuition, and confirms that harvesters have two behaviors that generate two significantly different trajectories: when they walk to the closest tree, or when they have to move to another part of the plot. The gamma distribution showed a lower AIC and is the best fitting for our data. We took two trajectories (Fran9 and Car12) to illustrate both states with the gamma distribution, where we can see the most likely states across the trajectories (Fig. 8).

```{r, echo=FALSE, message=FALSE}
modelos_p <- list("gamma" = 0, 
     "weibull" = 0)

for (i in seq(1,dim(DF_TOTAL_MIN)[1],1)){
  par0_p <- as.numeric(c(DF_TOTAL_MIN$pr_par0_st1[i], DF_TOTAL_MIN$pr_par0_st2[i]))
  par1_p <- as.numeric(c(DF_TOTAL_MIN$pr_par1_st1[i], DF_TOTAL_MIN$pr_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  #print(stepPar0_p)
  #op1
  m_cosecha_p<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(DF_TOTAL_MIN$model[i]))
  modelos_p[[as.character(DF_TOTAL_MIN$model[i])]] <- m_cosecha_p 
}

```


```{r echo=FALSE, fig.cap="Distribution of states $St$ along two trajectories. Each color follow the code of colors of Fig.7)", fig.keep=c(3,4), fig.show='hold', message=FALSE, out.width="50%"}

#plotStates(modelos_p$gamma, ask = F, animals = c( "H_Fran9", "I_Car12"))

plot(modelos_p$gamma, animals = c("H_Fran9", "I_Car12"), ask = F, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

## 3. Probabilities of states per farm

We now estimate, once the given distribution of states per trajectories, the

```{r echo=FALSE}

dataCosecha_V <- dataCosecha
dataCosecha_V$state <- viterbi(modelos_p$gamma)

dataCosecha_V <- dataCosecha_V %>%
  mutate(conteo = 1)%>%
  group_by(ID) %>%
  mutate(contador = cumsum(conteo))
  

binaryPlot <- dataCosecha_V %>%
  separate(ID, sep= "_", into = c("Farm", "ID"), remove = T) %>%
  ggplot(aes(x= contador , y= ID, fill= as.factor(state)))+
  geom_tile(col= "white")+
  facet_wrap(~Farm, scales= "free_y")+
  scale_fill_manual(values= groupColors2)+
  theme_bw()
  
dataStates <- dataCosecha_V %>%
  group_by(ID, state)%>%
  summarise(numStates = sum(conteo)) 

dataStates <- dataStates %>%
  ungroup()%>%  #no entiendo que estaba agrupado, supongo que el ID con el state...
  complete(ID, state)

dataStates$numStates[is.na(dataStates$numStates)] <- 0 


###AQUI MEQEUDEEEEEE FALTA HACER LA GRAFICA DE PORCENTAJE; VS FINCA; VS LONGITUD DE RECPRRIDO Y YA


```

```{r echo=FALSE, fig.cap="DDAII7)", message=FALSE}
binaryPlot

```



refe:

which in a very effective way considers all possible state sequences that might have given rise to the observed time series, exploiting the dependence structure of the model. (In fact, the availability of this and other recursion techniques is probably the key reason for the popularity of HMMs.) This makes numerical maximization of the (log-)likelihood, and hence maximum likelihood estimation, feasible in most cases. For a fitted model, one can easily obtain the most likely sequence of states and also examine various variables of interest such as the average rate of movement in each state. For a comprehensive account of the HMM machinery, we recommend Zucchini, MacDonald & Langrock (2016).

https://cran.r-project.org/web/packages/moveHMM/vignettes/moveHMM-guide.pdf

https://theomichelot.github.io/software/


