---
title: "Analysis of the trajectories of the harvesters using HMM"
output:
  pdf_document: default
bibliography: movehmm.bib
---

In this document I will present some results and interpretations of the analysis of the spatial trajectories of the harvesters using Hidden Markov Models (HMM).

## 0. Introduction to HMM 

Hidden Markov models (HMMs) are models in which the distribution that generates an observation $Z_t$ depends on the state $S_t$ of an underlying and unobserved Markov process (that satisfies the Markov property; Figure 1). In the context of animal movement, the state $S_t$ is interpreted as a proxy for the behavioral state of the animal (e.g. foraging, exploring). The observations $Zt$ are bivariate time series ($Zt = (l_t, \phi_t)$) where $l_t$ is the step length (the Euclidean distance) and $\phi_t$ the turning angle, between two succesive locations [@michelot2019movehmm, @zucchini2016hidden]. Biologically speaking, these models try to include the process where the movement of agents (e.g. short or large steps) depends on its behavior. With these models, we can define the most likely sequence of states along the trajectory of an agent, its average time within a state, and the number of switches between states.  

![Representation of the HMM. taken from (Michelot, Langrock and Patterson, 2019)](hmmfigure.png){width=50%}

Here we used the _movehmm_ library (@michelot2019movehmm) to i) fit the most likely HMM to the harvester movement data and ii) describe the different states, the sequence of states and the difference between farms. 

## 1. Fitting of HMM

### 1.1. Preparation of data

We loaded _ggplot2_, _dplyr_, _tidyverse_ and _movehmm_ libraries. We then loaded the data of the trajectories and did some punctual modifications to it. We had in total 12 trajectories, with ($x, y$) coordinates (Fig. 2).

```{r, message=FALSE, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(moveHMM)
library(knitr)
library(reshape2)
colorsGris <- c("black","#555555", "white")
groupColors3 <- c("#021128", "#fd9706", "#1b4a64" )
groupColors2 <- c("#021128", "#fd9706")
mycols3c <-c("#759580", "#1b4a64")
```


```{r, echo=FALSE, message=FALSE}
WP_COSECHA_UTM_SP <- read.csv("../data/cleanData_wayPointsCoffee_UTM.csv", stringsAsFactors = FALSE )

WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  mutate(finca = replace(finca, finca == "Irlanda", "I")) %>%
  mutate(finca = replace(finca, finca == "Hamburgo", "H"))

WP_COSECHA_UTM_SP$zona[WP_COSECHA_UTM_SP$zona == "falta"] <- "zonaBaja"
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>% rowwise() %>% 
  group_by(ID_REC, pante)%>%  #esto debe seguirse con lo de aajo
  mutate(xNorm = x_UTM - min(x_UTM)) %>%
  mutate(yNorm = y_UTM - min(y_UTM))

#now the precision (not the accuracy) of the GPS goes to 5 decimal points (lat y lot) and this is equivalent to ~1m
#so we can round the xNorm and y yNorm

WP_COSECHA_UTM_SP$xNorm <- round(WP_COSECHA_UTM_SP$xNorm, 0)
WP_COSECHA_UTM_SP$yNorm <- round(WP_COSECHA_UTM_SP$yNorm, 0)

#we remove some spurious data were delta = 0
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  filter(delta !=0)%>%
  unite("Finca_ID_REC", finca, ID_REC, remove = FALSE)

#we create this ID column to prepare the data for movehmm
WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP %>%
  dplyr::select("ID" = Finca_ID_REC, xNorm, yNorm)

WP_COSECHA_UTM_SP_PRE$pante <- NULL
WP_COSECHA_UTM_SP_PRE$ID_REC <- NULL
```

```{r echo=FALSE, warning=FALSE, fig.cap= "12 trajectories of harvesters. The green line represent the Farm Hamburgo (H) and the blue line the Farm Irlanda (I)." , fig.height= 12, fig.width=10}
mapHarvest_total<- WP_COSECHA_UTM_SP_PRE %>% 
  separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>% 
  ggplot(aes(x= xNorm, y = yNorm)) +
  geom_path(aes(col= Finca), size= 1)+
  geom_point(size=1)+ # es importante que sea path, porque así lo hace según coo estan ordenados los
  scale_color_manual(values= mycols3c)+
  facet_wrap(~ ID, ncol=3)+
  theme(panel.spacing = unit(0.8, "lines"), text = element_text(size = 15))+
  theme_bw()+
  labs(x= "X_norm", y= "Y_norm", col= "Farm")

#ggsave("../output/mapHarvest_I.png", height = 8, width = 12, device = "png")

mapHarvest_total
```
```{r, echo=FALSE}
dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros

summary(dataCosecha)
```

A first assumption for the analysis was made: we took these time irregular trajectories (where each point represents one different tree, but where the time between two trees is variable) and treated them as a regular trajectories. This aimed to analyze the change in the movement of the workers during a day, generated by the underlying pattern of trees or by the differences in the fruit charge and ripening synchronicity. We convert this database into a movehmm object where the step distance $l_t$ and the relative angle $\phi_t$ between the $(x, y)$ coordinates is calculated (table 1). We plotted the histograms of both the steps and the angles (Fig. 3 and Fig. 4). 


```{r echo=FALSE} 
kable(head(dataCosecha), caption = "First lines of the movehmm object")
```



```{r echo=FALSE, fig.cap= "Histogram of the steps lengths per farm", warning=FALSE, fig.height= 4, fig.width=8}
pHisto_step <-dataCosecha %>%
separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>%
  ggplot(aes(x= as.numeric(step), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=2, color= "black", aes(fill=as.character(Finca))) +
scale_fill_manual(values= mycols3c)+  
facet_wrap(~Finca)+
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Distance (in m)", y= "Proportion", fill= "Farm")
pHisto_step
```

```{r echo=FALSE, fig.cap= "Radial histogram of the relative angles, per farm",  warning=FALSE, fig.height= 4, fig.width=8}
pHisto_angle <-dataCosecha %>%
separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>%
  ggplot(aes(x= as.numeric(angle), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=0.5, color= "black", aes(fill=as.character(Finca))) +
    coord_polar(theta="x", start=pi/2, direction=-1)+
scale_fill_manual(values= mycols3c)+  
facet_wrap(~Finca)+
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Angle (in radians)", y= "Proportion", fill= "Farm")
pHisto_angle
```

Now, for the following analysis, we only took the step distance and treated both farms as one. We decided to exclude the angles because they didn't have a biological meaning for irregular trajectories. The input for the analysis is then the histogram presented in Fig. 5. 


```{r echo=FALSE, warning=FALSE, fig.cap= "Histogram of the steps lengths", fig.height= 6, fig.width=10}
pHisto_step_general <-dataCosecha %>%
  ggplot(aes(x= as.numeric(step), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=2, color= "black", aes(fill=as.character(ID))) +
scale_fill_viridis_d()+  
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Distance (in m)", y= "Proportion", fill= "ID")
pHisto_step_general
```


### 1.2. Fitting of the data


The algorithm of the _movehmm_ library uses:

a) a predefined number of states. Here we will use two. 

b) a defined family of distributions. Here we will try to fit two different exponential families (_gamma_ and _weibull_).

c) prior parameters for each of the distributions, for each state. 

d) The observations (step-lengths) (the data of harvesters)

With these inputs, the algorithm extracts the most likely two-state-distributions with their respective parameters (within the predefined family of distributions) that fit the data and the most likely sequence of states. During the fitting process, the algorithm uses the maximum-log likelihood and the _forward algorithm_ (a recursive algorithm starting with the prior distributions; [@zucchini2016hidden]).

We ran a loop to fit the two different families (_weibull_, and _gamma_) and in order to avoid local maximal likelihoods, we swapped 1000 combinations across a range of prior parameters for each model [@michelot2019movehmm]. For the _gamma_ distribution, the minimum and maximum values of each range were chosen to encompass the full distribution. For the _weibull_ distribution, the maximum shape considered the left-skew shape and the scale was chosen to include the 120m long steps (see ranges in table 2). It is important to note that these are only priors guesses, and the real parameters can outbound these limits. Many of these combinations of prior parameters will converge to the same final distributions.  

```{r, echo=FALSE}
rangosDist <- list("gamma" = list("mean" = c(0.1, 20), "sd" = c(0.1,20)), 
                   "weibull" = list("shape" = c(0, 2.7), "scale" = c(0.1,15))  ##segun el articulo
                   )

DF_rangos <- data.frame("value" = c("min", "max"))
DF_rangos <- cbind(DF_rangos, as.data.frame(rangosDist))
kable(DF_rangos, caption = "Minimun and maximum values of the parameters of the distribution")
```


```{r, echo=FALSE}
DF_TOTAL <- data.frame("model"= 0, 
            "prior_par0_st1_st2"= 0,
            "prior_par1_st1_st2" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0,
           "st2_par0"=0,
           "st2_par1"= 0)

repetitions <- seq(1, 1000,1)
runModel <- "no"
if (runModel == "yes"){
for (modelStep in c("weibull", "gamma")){
  print(modelStep)
  rangePar0 <- runif(100000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])
  rangePar1 <- runif(100000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2])
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE),
              sample(rangePar0,1, replace= TRUE)) # step mean (two parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE), 
              sample(rangePar1,1, replace= TRUE)) 
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 2 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha$mod$minimum
    AIC_model <- AIC(m_cosecha)
    
    DF_TEMP <- data.frame("model"= modelStep, 
                          "prior_par0_st1_st2"= paste(par0[1], "_", par0[2]), 
                          "prior_par1_st1_st2"=  paste(par1[1], "_", par1[2]),
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha$mle$stepPar[1,1],
                          "st1_par1"= m_cosecha$mle$stepPar[2,1],
                          "st2_par0"= m_cosecha$mle$stepPar[1,2],
                          "st2_par1"= m_cosecha$mle$stepPar[2,2])
    
                      
    DF_TOTAL <- rbind(DF_TOTAL, DF_TEMP)    
    
    
      }
}

DF_TOTAL <- DF_TOTAL%>%
  filter(model != 0)
}
#write_csv(DF_TOTAL, "../output/wholeTable_1000_rep_0_20.csv")
```


```{r, echo=FALSE}
DF_TOTAL_1000 <- read.csv("../output/wholeTable_1000_rep_0_20.csv")


DF_TOTAL_1000 <- DF_TOTAL_1000 %>%
  filter(model != "lnorm") %>%
  separate(prior_par0_st1_st2, c("pr_par0_st1", "pr_par0_st2"), sep= "_", remove = TRUE) %>%
  separate(prior_par1_st1_st2, c("pr_par1_st1", "pr_par1_st2"), sep= "_", remove = TRUE)

DF_TOTAL_1000$pr_par0_st1 <- as.numeric(DF_TOTAL_1000$pr_par0_st1)
DF_TOTAL_1000$pr_par1_st1 <- as.numeric(DF_TOTAL_1000$pr_par1_st1)
DF_TOTAL_1000$pr_par0_st2 <- as.numeric(DF_TOTAL_1000$pr_par0_st2)
DF_TOTAL_1000$pr_par1_st2 <- as.numeric(DF_TOTAL_1000$pr_par1_st2)

DF_TOTAL_1000[,seq(2,11,1)] <- round(DF_TOTAL_1000[,seq(2,11,1)], 2)

```


For each combination of parameters we registered the final parameters and the minimum negative log-likelihood (table 2). The mininumm negative log-likelihood is equivalent to the maximum likelihood but works better in the fast forward algorithm (ref.). 

```{r, echo=FALSE}
kable(head(DF_TOTAL_1000), caption = "Examples of the results of the algorithm")
```

Some results registered combinations where one of the final parameters created distributions with zero variance. We decided to remove those cases as they did not make any biological sense. We then plot the min negative log of the likelihood without these outliers (fig*)

```{r, echo=FALSE}
#here we have the outiers that were removed
DF_1000_OUTLIERS <- DF_TOTAL_1000 %>%
  filter(st1_par1 <0.00001 | st2_par1 <0.00001)

DF_1000_OUTLIERS <- DF_1000_OUTLIERS %>%
  group_by(model) %>%
  mutate(conteo = 1)%>%
  mutate(contador = cumsum(conteo))
```



```{r, echo=FALSE}
DF_1000_SIN <- DF_TOTAL_1000 %>%
  filter(st1_par1 >0.00001 & st2_par1 >0.00001)
```


```{r, fig.cap= "Minimun Negative Log-likelihood per combination of prior parameters for three different distributions", echo=FALSE}
FIG_AIC_model <- DF_1000_SIN %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot()+
  geom_jitter(aes(x= model, y= minNegLike, shape= model, fill= model), size= 4)+
  #scale_fill_manual(values = colorsGris) +
  scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_AIC_model
```

We then chose, for each family of distributions the model that had the minimun AIC value (table 3). 

```{r, echo=FALSE}
DF_TOTAL_MIN <- DF_1000_SIN %>%
  group_by(model)%>%
  filter(AIC_model == min(AIC_model)) %>%
  group_by(model, AIC_model) %>%
  mutate(conteo = 1)%>%
  mutate(contador= cumsum(conteo))%>%
  filter(contador ==1)

DF_TOTAL_MIN$conteo <- NULL
DF_TOTAL_MIN$contador <- NULL

kable(DF_TOTAL_MIN, caption = "Best models (minimal AIC) for each of the distribution")
```


### 2. Description of the states, for each studied distribution. 

Now that we have the best two state model for each of the distributions, we will describe the states $S_t$ they produced, their sequence and the observed differences between the farms.



```{r, echo=FALSE}
modelos_p <- list("gamma" = 0, 
     "weibull" = 0)

for (i in seq(1,dim(DF_TOTAL_MIN)[1],1)){
  par0_p <- as.numeric(c(DF_TOTAL_MIN$pr_par0_st1[i], DF_TOTAL_MIN$pr_par0_st2[i]))
  par1_p <- as.numeric(c(DF_TOTAL_MIN$pr_par1_st1[i], DF_TOTAL_MIN$pr_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  #print(stepPar0_p)
  #op1
  m_cosecha_p<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(DF_TOTAL_MIN$model[i]))
  modelos_p[[as.character(DF_TOTAL_MIN$model[i])]] <- m_cosecha_p 
}

```

#### 2.1. Gamma model


```{r, fig.show='hold', out.width="50%", echo=FALSE, fig.cap="Gamma model"}
plot(modelos_p$gamma, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```


#### 2.2. Weibull model

```{r, fig.show='hold', out.width="50%", echo=FALSE, fig.cap="Weibull model"}
plot(modelos_p$weibull, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```








```{r echo=FALSE}
# DF_1000_OUTLIERS_MELT <- DF_1000_OUTLIERS %>%
#   dplyr:: select(model, st1_par0, st1_par1, st2_par0, st2_par1, contador)%>%
#   melt(id = c("model", "contador")) %>%
#   separate(variable, into = c("state", "parameter"), sep= "_")
# 
# DF_par0 <- DF_1000_OUTLIERS_MELT %>%
#   filter(parameter == "par0")
# 
# DF_1000_OUTLIERS_MELT <- DF_1000_OUTLIERS_MELT %>%
#   filter(parameter == "par1")
# 
# DF_1000_OUTLIERS_MELT <- merge(DF_1000_OUTLIERS_MELT, DF_par0, by= c("model", "contador", "state"))
```

```{r echo=FALSE}
# FIG_Parameters_OUT <- DF_1000_OUTLIERS_MELT %>% 
#   filter(contador <6)%>% 
#   ggplot(aes(x= state, y = value.y))+
#   geom_point(col= "black",  size= 2)+
#   geom_errorbar(size=0.5, aes(
#     ymin=value.y- value.x,  ymax=value.y+ value.x), col = "blue") +
#   scale_color_viridis_d()+
#   facet_grid(model~contador)+
#   scale_shape_manual(values = c(21, 24, 22))+
#   theme_bw()
# 
# FIG_Parameters_OUT
```
refe:

which in a very effective way considers all possible state sequences that might have given rise to the observed time series, exploiting the dependence structure of the model. (In fact, the availability of this and other recursion techniques is probably the key reason for the popularity of HMMs.) This makes numerical maximization of the (log-)likelihood, and hence maximum likelihood estimation, feasible in most cases. For a fitted model, one can easily obtain the most likely sequence of states and also examine various variables of interest such as the average rate of movement in each state. For a comprehensive account of the HMM machinery, we recommend Zucchini, MacDonald & Langrock (2016).

https://cran.r-project.org/web/packages/moveHMM/vignettes/moveHMM-guide.pdf

https://theomichelot.github.io/software/


