---
title: "R Notebook"
output: html_notebook
---

#Analisis de las trayectorias usando HMM (Hidden Markov Chains)


```{r}
library(ggplot2)
library(viridis)
library(dplyr)
library(tidyverse)
library(moveHMM)
colorsGris <- c("black","#555555", "white")
groupColors3 <- c("#021128", "#fd9706", "#1b4a64" )

```


I. We load the data from the trajectories and do some punctual modifications
```{r}
WP_COSECHA_UTM_SP <- read.csv("../data/cleanData_wayPointsCoffee_UTM.csv", stringsAsFactors = FALSE )

WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  mutate(finca = replace(finca, finca == "Irlanda", "I")) %>%
  mutate(finca = replace(finca, finca == "Hamburgo", "H"))

WP_COSECHA_UTM_SP$zona[WP_COSECHA_UTM_SP$zona == "falta"] <- "zonaBaja"

WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>% rowwise() %>% 
  group_by(ID_REC, pante)%>%  #esto debe seguirse con lo de aajo
  mutate(xNorm = x_UTM - min(x_UTM)) %>%
  mutate(yNorm = y_UTM - min(y_UTM))

#now the precision (not the accuracy) of the GPS goes to 5 decimal points (lat y lot) and this is equivalent to ~1m
#so we can round the xNorm and y yNorm

WP_COSECHA_UTM_SP$xNorm <- round(WP_COSECHA_UTM_SP$xNorm, 0)
WP_COSECHA_UTM_SP$yNorm <- round(WP_COSECHA_UTM_SP$yNorm, 0)

#we remove some spurious data were delta = 0
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  filter(delta !=0)%>%
  unite("Finca_ID_REC", finca, ID_REC, remove = FALSE)

#we create this ID column to prepare the data for movehmm
WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP %>%
  dplyr::select("ID" = Finca_ID_REC, xNorm, yNorm)

WP_COSECHA_UTM_SP_PRE$pante <- NULL
WP_COSECHA_UTM_SP_PRE$ID_REC <- NULL

head(WP_COSECHA_UTM_SP_PRE)
```

We create the data for movehmm
```{r}
dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros

summary(dataCosecha)
#anglesFalse <- runif(dim(dataCosecha)[1], -pi, pi)
#dataCosecha$angle <- anglesFalse

head(dataCosecha)
```

We are going to keep the irregular trayectory, and only use the step-length. (to only register the big displacements, independently of the time)

```{r}
rangosDist <- list("gamma" = list("mean" = c(0.1, 15), "sd" = c(0.1,15)), 
                   "weibull" = list("shape" = c(0, 2.7), "scale" = c(0.1,15)),  ##segun el articulo
                   "lnorm" =  list("location" = c(-1, 20), "scale" = c(0.001,3)))

DF_TOTAL <- data.frame("model"= 0, 
            "prior_par0_st1_st2"= 0,
            "prior_par1_st1_st2" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0,
           "st2_par0"=0,
           "st2_par1"= 0)


###loop to explore  multiple combinations of parameters

repetitions <- seq(1, 1000,1)
runModel <- "no"
if (runModel == "yes"){
for (modelStep in c("weibull", "gamma", "lnorm")){
  print(modelStep)
  rangePar0 <- runif(100000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])
  rangePar1 <- runif(100000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2])
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE),
              sample(rangePar0,1, replace= TRUE)) # step mean (two parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE), 
              sample(rangePar1,1, replace= TRUE)) 
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 2 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha$mod$minimum
    AIC_model <- AIC(m_cosecha)
    
    DF_TEMP <- data.frame("model"= modelStep, 
                          "prior_par0_st1_st2"= paste(par0[1], "_", par0[2]), 
                          "prior_par1_st1_st2"=  paste(par1[1], "_", par1[2]),
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha$mle$stepPar[1,1],
                          "st1_par1"= m_cosecha$mle$stepPar[2,1],
                          "st2_par0"= m_cosecha$mle$stepPar[1,2],
                          "st2_par1"= m_cosecha$mle$stepPar[2,2])
    
                      
    DF_TOTAL <- rbind(DF_TOTAL, DF_TEMP)    
    
    
      }
}

DF_TOTAL <- DF_TOTAL%>%
  filter(model != 0)
}
#write_csv(DF_TOTAL, "../output/wholeTable_1000_rep_0_20.csv")
```

Now from that total, we explore the different AIC values

```{r}
DF_TOTAL_1000 <- read.csv("../output/wholeTable_1000_rep_0_20.csv")
DF_TOTAL_1000 <- DF_TOTAL_1000 %>%
  separate(prior_par0_st1_st2, c("prior_par0_st1", "prior_par0_st2"), sep= "_", remove = TRUE) %>%
  separate(prior_par1_st1_st2, c("prior_par1_st1", "prior_par1_st2"), sep= "_", remove = TRUE)



FIG_AIC_model <- DF_TOTAL_1000 %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_jitter(aes(x= model, y= AIC_model, shape= model, fill= model), size= 4)+
  #scale_fill_manual(values = colorsGris) +
  scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_AIC_model
```


From this we can see that for some specific values of prior parameters, the AIC reaches some minimal values, for each model

```{r}
DF_1000_OUTLIERS <- DF_TOTAL_1000 %>%
  filter(AIC_model <=4500)
DF_1000_OUTLIERS[,c(6,7,8,9)] <- round(DF_1000_OUTLIERS[,c(6,7,8,9)], 3)


```
We can see that for gamma distribution, all the outliers (with minimum AIC)
suggest two equivalent states

gamma
state 1: gamma(location: [4-9], shape [3-7]). This is a state that will characterize almost all steps. 
state 2: gamma(location: [2], shape [0])- A state that only considers the 2 m steps, with no variance. 

lnorm
state 1: lnorm([1.498-1.6], shape: 0). Astate that ony considers
state 2 lnorm ([1.4], [0.6])

We show now the representations of both of theses distrributions (we choose 2 lines randomly with the same priors)

```{r}

DF_1000_OUTLIERS<- DF_1000_OUTLIERS %>%
  mutate(contador = 1)%>%
  group_by(model) %>%
  mutate(countModel = cumsum(contador))

OUTLIERS_EX <- DF_1000_OUTLIERS %>%
  filter(countModel == 1)

modelos_OUTLIERS <- list("gamma" = 0, 
     "gamma" = 0,  ##segun el articulo
     "lnorm" =  0)

for (i in seq(1, dim(OUTLIERS_EX)[1],1)){
  par0_p <- as.numeric(c(OUTLIERS_EX$prior_par0_st1[i], OUTLIERS_EX$prior_par0_st2[i]))
  par1_p <- as.numeric(c(OUTLIERS_EX$prior_par1_st1[i], OUTLIERS_EX$prior_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  print(stepPar0_p)
  #op1
  m_cosecha_OUT<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(OUTLIERS_EX$model[i]))
  modelos_OUTLIERS[[as.character(OUTLIERS_EX$model[i])]] <- m_cosecha_OUT 
}


```
```{r}
plot(modelos_OUTLIERS$gamma, animals = c("I_Car12", "I_MigSam4", "H_Fran6", "H_Fran9"), ask = FALSE, plotTracks = TRUE)
```


```{r}
plot(modelos_OUTLIERS$lnorm, animals = c("I_Car12", "I_MigSam4", "H_Fran6", "H_Fran9"), ask = FALSE, plotTracks = TRUE)
```

As we can see, it only separates the model when the variance is null for one distribtuon, this does not make any biological sense. 

So now, we are going to plot the exmples without these outliers, and plot the mininum AIC

```{r}
DF_TOTAL_MIN <- DF_TOTAL_1000 %>%
  filter(AIC_model > 4500)%>%
  group_by(model)%>%
  filter(AIC_model == min(AIC_model))
```

```{r}


modelos_p <- list("gamma" = 0, 
     "weibull" = 0,  ##segun el articulo
     "lnorm" =  0)

for (i in seq(1,dim(DF_TOTAL_MIN)[1],1)){
  par0_p <- as.numeric(c(DF_TOTAL_MIN$prior_par0_st1[i], DF_TOTAL_MIN$prior_par0_st2[i]))
  par1_p <- as.numeric(c(DF_TOTAL_MIN$prior_par1_st1[i], DF_TOTAL_MIN$prior_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  print(stepPar0_p)
  #op1
  m_cosecha_p<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(DF_TOTAL_MIN$model[i]))
  modelos_p[[as.character(DF_TOTAL_MIN$model[i])]] <- m_cosecha_p 
}


```


```{r}
plot(modelos_p$gamma, animals = c("I_Car12", "I_MigSam4", "H_Fran6", "H_Fran9"), ask = FALSE, plotTracks = TRUE)
```

```{r}
plot(modelos_p$lnorm, animals = c("I_Car12", "I_MigSam4", "H_Fran6", "H_Fran9"), ask = FALSE, plotTracks = TRUE)
```
```{r}
plot(modelos_p$weibull, animals = c("I_Car12", "I_MigSam4", "H_Fran6", "H_Fran9"), ask = FALSE, plotTracks = TRUE)
```




```{r}
FIG_AIC_model <- DF_TOTAL %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_boxplot(aes(fill= model))+
  geom_jitter(aes(x= model, y= AIC_model), col= "darkred")+
  scale_fill_manual(values = colorsGris) +
  theme_bw()

#ggsave(FIG_AIC_model,filename=paste("../output/", "FIG_AIC_MODEL_100", ".png", sep=""),  height = 5, width = 16) # ID will be the unique identifier. and change the extension from .png to whatever you like (eps, pdf etc)

FIG_AIC_model_sinOut <- DF_TOTAL %>% 
  filter(AIC_model != "Inf")%>% 
  filter(AIC_model >4000)%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_boxplot(aes(fill= model), width = 0.2)+
  geom_jitter(aes(x= model, y= AIC_model), col= "darkred", width = 0.1)+
  scale_fill_manual(values = colorsGris)+
  theme_bw()

#ggsave(FIG_AIC_model_sinOut,filename=paste("../output/", "FIG_AIC_100_SINOUT_MODEL", ".png", sep=""),  height = 5, width = 16) # ID will be the unique identifier. and change the extension from .png to whatever you like (eps, pdf etc)

```

