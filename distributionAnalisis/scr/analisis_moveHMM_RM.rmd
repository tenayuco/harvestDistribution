---
title: "Insights on the trajectories of harvesters using HMM"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
  author: Emilio Mora
---

In this document I will explain the main results and interpretations of the analysis of the spatial trajectories of the harvesters using Hidden Markov Models (HMM)

## I. Preparation of data   

We load ggplot2, dplyr, tidyverse and movehmm libraries used during the analysis. We then load the data of the trajectories and do some punctual modifications to it. We show here the first rows. 

```{r, message=FALSE, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(moveHMM)
library(reshape2)
colorsGris <- c("black","#555555", "white")
groupColors3 <- c("#021128", "#fd9706", "#1b4a64" )
groupColors2 <- c("#021128", "#fd9706")
mycols3c <-c("#759580", "#1b4a64")

```


```{r, echo=FALSE, message=FALSE}
WP_COSECHA_UTM_SP <- read.csv("../data/cleanData_wayPointsCoffee_UTM.csv", stringsAsFactors = FALSE )

WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  mutate(finca = replace(finca, finca == "Irlanda", "I")) %>%
  mutate(finca = replace(finca, finca == "Hamburgo", "H"))

WP_COSECHA_UTM_SP$zona[WP_COSECHA_UTM_SP$zona == "falta"] <- "zonaBaja"
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>% rowwise() %>% 
  group_by(ID_REC, pante)%>%  #esto debe seguirse con lo de aajo
  mutate(xNorm = x_UTM - min(x_UTM)) %>%
  mutate(yNorm = y_UTM - min(y_UTM))

#now the precision (not the accuracy) of the GPS goes to 5 decimal points (lat y lot) and this is equivalent to ~1m
#so we can round the xNorm and y yNorm

WP_COSECHA_UTM_SP$xNorm <- round(WP_COSECHA_UTM_SP$xNorm, 0)
WP_COSECHA_UTM_SP$yNorm <- round(WP_COSECHA_UTM_SP$yNorm, 0)

#we remove some spurious data were delta = 0
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  filter(delta !=0)%>%
  unite("Finca_ID_REC", finca, ID_REC, remove = FALSE)

#we create this ID column to prepare the data for movehmm
WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP %>%
  dplyr::select("ID" = Finca_ID_REC, xNorm, yNorm)

WP_COSECHA_UTM_SP_PRE$pante <- NULL
WP_COSECHA_UTM_SP_PRE$ID_REC <- NULL
```
```{r}
head(WP_COSECHA_UTM_SP_PRE)
```

And the next figure show the different trajectories per farm. 


```{r echo=FALSE, warning=FALSE, fig.height= 12, fig.width=10}
mapHarvest_total<- WP_COSECHA_UTM_SP_PRE %>% 
  separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>% 
  ggplot(aes(x= xNorm, y = yNorm)) +
  geom_path(aes(col= Finca), size= 1)+
  geom_point(size=1)+ # es importante que sea path, porque así lo hace según coo estan ordenados los
  scale_color_manual(values= mycols3c)+
  facet_wrap(~ ID, ncol=3)+
  theme(panel.spacing = unit(0.8, "lines"), text = element_text(size = 15))+
  theme_bw()+
  labs(x= "X_norm", y= "Y_norm", col= "Farm")

#ggsave("../output/mapHarvest_I.png", height = 8, width = 12, device = "png")

mapHarvest_total
```


In this first approach, we made no difference between the two farms for the analysis of the states (but will use it a posteriori). A first assumption for the analysis is made: we took these time irregular trajectories (where each point represents one different tree, but where the time between two trees is variable) and will treat them as a regular trajectories. We only want to analyze if the movement of the workers across the plots has different states (taking all the trajectories into account). This also assumes that the underneath pattern of trees is relatively homogeneous and is not the main determinant of the trajectories. We convert this data base into a movehmm object: 

```{r, echo=FALSE}
dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros
summary(dataCosecha)
```

```{r}
head(dataCosecha)
```

We can see that the distance step and the relative angle is calculated for each of the 12 trajectories. We show the histograms of both the steps and the angles. We separate colors for the different farms, but we will treat it as the same (and then analyze the frequency of states per farm). 



```{r echo=FALSE, warning=FALSE, fig.height= 4, fig.width=8}
pHisto_step <-dataCosecha %>%
separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>%
  ggplot(aes(x= as.numeric(step), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=2, color= "black", aes(fill=as.character(Finca))) +
scale_fill_manual(values= mycols3c)+  
facet_wrap(~Finca)+
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Distance (in m)", y= "Proportion", fill= "Farm")
pHisto_step
```

```{r echo=FALSE, warning=FALSE, fig.height= 4, fig.width=8}
pHisto_angle <-dataCosecha %>%
separate(ID, into = c("Finca", "IDREC"), sep = "_", remove = FALSE)%>%
  ggplot(aes(x= as.numeric(angle), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=0.5, color= "black", aes(fill=as.character(Finca))) +
    coord_polar(theta="x", start=pi/2, direction=-1)+
scale_fill_manual(values= mycols3c)+  
facet_wrap(~Finca)+
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Angle (in radians)", y= "Proportion", fill= "Farm")
pHisto_angle
```

Now, for the following analysis, we will only use the step distance and treat both farms as one. We decide to not include the angles to simplify the analysis and interpretation. In this sense, the input for the analysis is the following histogram:


```{r echo=FALSE, warning=FALSE, fig.height= 6, fig.width=10}
pHisto_step_general <-dataCosecha %>%
  ggplot(aes(x= as.numeric(step), y=(..count..)/tapply(..count..,..PANEL..,sum)[..PANEL..])) +
  geom_histogram(binwidth=2, color= "black", aes(fill=as.character(ID))) +
scale_fill_viridis_d()+  
  theme(panel.spacing = unit(0.8, "lines"),
        text = element_text(size = 15))+
  theme_bw()+ 
   labs(x= "Distance (in m)", y= "Proportion", fill= "ID")
pHisto_step_general
```


## II. Movehmm analysis

The library movehmm uses HMM to separate trajectories into multiple states (the hidden markov states) that are supposed to belong to specific probability distributions (e.g. gamma, lnorm, weibull) using the "emissions" of the states (in this case, the step lengths or angles). The algorithm estimates the most likely distributions of angles and step length of each state, the transition probabilities and the probabilty of each of the "emissions" to come from each of the states. 

It uses: 

- a predefined distribution with prior parameters (guesses)
- a dataset of step lengths and angles (here we will only use the step lengths)
- a predefined number of states

#### a) Priors parameters

We used 3 different models for the step lengths to approach the distributions of the states (weibull, lnorm and gamma). In order to avoid local maximal likelihoods, we swapped across a range of prior parameters for each model (1000). The min and max values of each range were chosen using ** and trying to use distribution that could encompass the histogram presented previously (gamma and weibull parameters). For the weibull distribution, the maximum shape was considering the left-skew and the scale was consider to include the 120 m steps. It is important to note that these are only priors guesses, and the real parameters can outbound these limits. Many these combinations of prior parameters converge to the same final parameters.  



```{r, echo=FALSE}
rangosDist <- list("gamma" = list("mean" = c(0.1, 20), "sd" = c(0.1,20)), 
                   "weibull" = list("shape" = c(0, 2.7), "scale" = c(0.1,15)),  ##segun el articulo
                   "lnorm" =  list("location" = c(-1, 20), "scale" = c(0.001,3)))

DF_rangos <- data.frame("value" = c("min", "max"))
DF_rangos <- cbind(DF_rangos, as.data.frame(rangosDist))
DF_rangos
```


#### b) States, models and whole loop

After this decision, we predefined 2 states and load the database. We ran the models for the 1000 combinations of priors and the 3 distributions. For each model we register the minimum negative-likelihood and the minimum AIC (both values should be proportional, since all the models have the same number of parameters). 

```{r, echo=FALSE}
DF_TOTAL <- data.frame("model"= 0, 
            "prior_par0_st1_st2"= 0,
            "prior_par1_st1_st2" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0,
           "st2_par0"=0,
           "st2_par1"= 0)

repetitions <- seq(1, 1000,1)
runModel <- "no"
if (runModel == "yes"){
for (modelStep in c("weibull", "gamma", "lnorm")){
  print(modelStep)
  rangePar0 <- runif(100000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])
  rangePar1 <- runif(100000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2])
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE),
              sample(rangePar0,1, replace= TRUE)) # step mean (two parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE), 
              sample(rangePar1,1, replace= TRUE)) 
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 2 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha$mod$minimum
    AIC_model <- AIC(m_cosecha)
    
    DF_TEMP <- data.frame("model"= modelStep, 
                          "prior_par0_st1_st2"= paste(par0[1], "_", par0[2]), 
                          "prior_par1_st1_st2"=  paste(par1[1], "_", par1[2]),
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha$mle$stepPar[1,1],
                          "st1_par1"= m_cosecha$mle$stepPar[2,1],
                          "st2_par0"= m_cosecha$mle$stepPar[1,2],
                          "st2_par1"= m_cosecha$mle$stepPar[2,2])
    
                      
    DF_TOTAL <- rbind(DF_TOTAL, DF_TEMP)    
    
    
      }
}

DF_TOTAL <- DF_TOTAL%>%
  filter(model != 0)
}
#write_csv(DF_TOTAL, "../output/wholeTable_1000_rep_0_20.csv")
```

We plot the different AIC values for all the models and combinations of parameters: 

```{r, echo=FALSE}
DF_TOTAL_1000 <- read.csv("../output/wholeTable_1000_rep_0_20.csv")
DF_TOTAL_1000 <- DF_TOTAL_1000 %>%
  separate(prior_par0_st1_st2, c("prior_par0_st1", "prior_par0_st2"), sep= "_", remove = TRUE) %>%
  separate(prior_par1_st1_st2, c("prior_par1_st1", "prior_par1_st2"), sep= "_", remove = TRUE)

DF_TOTAL_1000$prior_par0_st1 <- as.numeric(DF_TOTAL_1000$prior_par0_st1)
DF_TOTAL_1000$prior_par1_st1 <- as.numeric(DF_TOTAL_1000$prior_par1_st1)
DF_TOTAL_1000$prior_par0_st2 <- as.numeric(DF_TOTAL_1000$prior_par0_st2)
DF_TOTAL_1000$prior_par1_st2 <- as.numeric(DF_TOTAL_1000$prior_par1_st2)

DF_TOTAL_1000[,seq(2,11,1)] <- round(DF_TOTAL_1000[,seq(2,11,1)], 2)

```



```{r, echo=FALSE}
FIG_AIC_model <- DF_TOTAL_1000 %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_jitter(aes(x= model, y= AIC_model, shape= model, fill= model), size= 4)+
  #scale_fill_manual(values = colorsGris) +
  scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_AIC_model
```

From this figure we note that in every model, almost all model generate 1 or 2 AIC values, but in the case of the gamma and lnorm distributions we can see some specific outliers that have minimal AIC values (less than 4500). Before taking these models for granted we decided to explore its resulting parameters and biological meaning. 

We filter the priors and resulting parameters for these outliers: 

```{r, echo=FALSE}
DF_1000_OUTLIERS <- DF_TOTAL_1000 %>%
  filter(AIC_model <=5250)

DF_1000_OUTLIERS <- DF_1000_OUTLIERS %>%
  group_by(model) %>%
  mutate(conteo = 1)%>%
  mutate(contador = cumsum(conteo))
DF_1000_OUTLIERS
```


```{r echo=FALSE}
DF_1000_OUTLIERS_MELT <- DF_1000_OUTLIERS %>%
  dplyr:: select(model, st1_par0, st1_par1, st2_par0, st2_par1, contador)%>%
  melt(id = c("model", "contador")) %>%
  separate(variable, into = c("state", "parameter"), sep= "_")

DF_par0 <- DF_1000_OUTLIERS_MELT %>%
  filter(parameter == "par0")

DF_1000_OUTLIERS_MELT <- DF_1000_OUTLIERS_MELT %>%
  filter(parameter == "par1")

DF_1000_OUTLIERS_MELT <- merge(DF_1000_OUTLIERS_MELT, DF_par0, by= c("model", "contador", "state"))
```

If we plot 5 examples of the parameter 1 (blue dots as it represent a measure of the mean) and the parameter 2 (blue line, as it represents a measure of variance) for each of the model we get the following figure: 

```{r echo=FALSE}
FIG_Parameters_OUT <- DF_1000_OUTLIERS_MELT %>% 
  filter(contador <6)%>% 
  ggplot(aes(x= state, y = value.y))+
  geom_point(col= "black",  size= 2)+
  geom_errorbar(size=0.5, aes(
    ymin=value.y- value.x,  ymax=value.y+ value.x), col = "blue") +
  scale_color_viridis_d()+
  facet_grid(model~contador)+
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_Parameters_OUT
```

We note that in both cases, one of the state has 0 variance (and a particular low value of the mean) and the other state has non null variance. In this sense, this second stae represents almost all the steps. If we observe (using the viterbi algoritm) how these model divide the trajectories:

```{r, echo=FALSE}

DF_1000_OUTLIERS<- DF_1000_OUTLIERS %>%
  mutate(contador = 1)%>%
  group_by(model) %>%
  mutate(countModel = cumsum(contador))

OUTLIERS_EX <- DF_1000_OUTLIERS %>%
  filter(countModel == 1)

modelos_OUTLIERS <- list("gamma" = 0, 
     "gamma" = 0,  ##segun el articulo
     "lnorm" =  0)

for (i in seq(1, dim(OUTLIERS_EX)[1],1)){
  par0_p <- as.numeric(c(OUTLIERS_EX$prior_par0_st1[i], OUTLIERS_EX$prior_par0_st2[i]))
  par1_p <- as.numeric(c(OUTLIERS_EX$prior_par1_st1[i], OUTLIERS_EX$prior_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  print(stepPar0_p)
  #op1
  m_cosecha_OUT<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(OUTLIERS_EX$model[i]))
  modelos_OUTLIERS[[as.character(OUTLIERS_EX$model[i])]] <- m_cosecha_OUT 
}
```

For the gamma distribution (we show an example with 2 trajectories)
```{r, fig.show='hold', out.width="50%", echo= FALSE}
plot(modelos_OUTLIERS$gamma, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

For the lnorm distribution (we show an example with 2 trajectories)
```{r, fig.show='hold', out.width="50%", echo=FALSE}
plot(modelos_OUTLIERS$lnorm, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

As we can see, the algorithm considers one state for the really small steps  (<4 m) and other state for all the other step lengths. This is interesting but it doe not makes sense to assume on distribution without any variance. In this sense, we assume that it makes sense to remove these outliers. 

If we plot the AIC figures without the outliers we have: 
```{r, echo=FALSE}
FIG_AIC_model_sin <- DF_TOTAL_1000 %>% 
  filter(AIC_model != "Inf")%>% 
  filter(AIC_model > 5250)%>%
  ggplot(aes(x= model, y= AIC_model))+
  geom_jitter(aes(x= model, y= AIC_model, shape= model, fill= model), size= 4)+
  #scale_fill_manual(values = colorsGris) +
  scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_AIC_model_sin
```

We observe some minimum values per model, that we are going to use. 

```{r}
DF_TOTAL_MIN <- DF_TOTAL_1000 %>%
  filter(AIC_model > 4500)%>%
  group_by(model)%>%
  filter(AIC_model == min(AIC_model)) %>%
  group_by(model, AIC_model) %>%
  mutate(conteo = 1)%>%
  mutate(contador= cumsum(conteo))%>%
  filter(contador ==1)
```

```{r}


modelos_p <- list("gamma" = 0, 
     "weibull" = 0,  ##segun el articulo
     "lnorm" =  0)

for (i in seq(1,dim(DF_TOTAL_MIN)[1],1)){
  par0_p <- as.numeric(c(DF_TOTAL_MIN$prior_par0_st1[i], DF_TOTAL_MIN$prior_par0_st2[i]))
  par1_p <- as.numeric(c(DF_TOTAL_MIN$prior_par1_st1[i], DF_TOTAL_MIN$prior_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  print(stepPar0_p)
  #op1
  m_cosecha_p<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(DF_TOTAL_MIN$model[i]))
  modelos_p[[as.character(DF_TOTAL_MIN$model[i])]] <- m_cosecha_p 
}


```


```{r, fig.show='hold', out.width="50%"}
plot(modelos_p$gamma, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

```{r, fig.show='hold', out.width="50%"}
plot(modelos_p$lnorm, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

```{r, fig.show='hold', out.width="50%"}
plot(modelos_p$weibull, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```





```{r}
FIG_AIC_model <- DF_TOTAL %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_boxplot(aes(fill= model))+
  geom_jitter(aes(x= model, y= AIC_model), col= "darkred")+
  scale_fill_manual(values = colorsGris) +
  theme_bw()

#ggsave(FIG_AIC_model,filename=paste("../output/", "FIG_AIC_MODEL_100", ".png", sep=""),  height = 5, width = 16) # ID will be the unique identifier. and change the extension from .png to whatever you like (eps, pdf etc)

FIG_AIC_model_sinOut <- DF_TOTAL %>% 
  filter(AIC_model != "Inf")%>% 
  filter(AIC_model >4000)%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_boxplot(aes(fill= model), width = 0.2)+
  geom_jitter(aes(x= model, y= AIC_model), col= "darkred", width = 0.1)+
  scale_fill_manual(values = colorsGris)+
  theme_bw()

#ggsave(FIG_AIC_model_sinOut,filename=paste("../output/", "FIG_AIC_100_SINOUT_MODEL", ".png", sep=""),  height = 5, width = 16) # ID will be the unique identifier. and change the extension from .png to whatever you like (eps, pdf etc)

```

