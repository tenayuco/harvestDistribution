---
title: "Insights on the movement of harvesters using HMM"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

## I. Preparation of data   

We load ggplot2, dplyr, tidyverse and movehmm libraries used during the analysis. 
```{r, message=FALSE, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(moveHMM)
colorsGris <- c("black","#555555", "white")
groupColors3 <- c("#021128", "#fd9706", "#1b4a64" )
groupColors2 <- c("#021128", "#fd9706")
```

We then load the data of the trajectories and do some punctual modifications on it:

```{r, echo=FALSE, message=FALSE}
WP_COSECHA_UTM_SP <- read.csv("../data/cleanData_wayPointsCoffee_UTM.csv", stringsAsFactors = FALSE )

WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  mutate(finca = replace(finca, finca == "Irlanda", "I")) %>%
  mutate(finca = replace(finca, finca == "Hamburgo", "H"))

WP_COSECHA_UTM_SP$zona[WP_COSECHA_UTM_SP$zona == "falta"] <- "zonaBaja"
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>% rowwise() %>% 
  group_by(ID_REC, pante)%>%  #esto debe seguirse con lo de aajo
  mutate(xNorm = x_UTM - min(x_UTM)) %>%
  mutate(yNorm = y_UTM - min(y_UTM))

#now the precision (not the accuracy) of the GPS goes to 5 decimal points (lat y lot) and this is equivalent to ~1m
#so we can round the xNorm and y yNorm

WP_COSECHA_UTM_SP$xNorm <- round(WP_COSECHA_UTM_SP$xNorm, 0)
WP_COSECHA_UTM_SP$yNorm <- round(WP_COSECHA_UTM_SP$yNorm, 0)

#we remove some spurious data were delta = 0
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  filter(delta !=0)%>%
  unite("Finca_ID_REC", finca, ID_REC, remove = FALSE)

#we create this ID column to prepare the data for movehmm
WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP %>%
  dplyr::select("ID" = Finca_ID_REC, xNorm, yNorm)

WP_COSECHA_UTM_SP_PRE$pante <- NULL
WP_COSECHA_UTM_SP_PRE$ID_REC <- NULL
```
```{r}
head(WP_COSECHA_UTM_SP_PRE)
```

We convert it to a movehmm object:
```{r, echo=FALSE}
dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros
summary(dataCosecha)
```

```{r}
head(dataCosecha)
```

Now, we are going to keep the time-irregular trajectory and treat as a regular trajectory. This implies that we can't assume velocity of the workers. Nonetheless, this analysis helps us to see the pattern of workers across the trees and differentiate short and large steps between trees, during harvesting. Also we will only use, to simplify, the steplength to caracterize the movement.

```{r}
hist(dataCosecha$step, breaks = 100)
```

## II. Movehmm analysis

The library movehmm uses a Hidden Markov Model (HMM) to characterize states (the HMM) that belong to a specific distribution (gamma, weibull or lnorm) using "emissions" of the states (aka the steps lengths) and calculating, using a likelihood function, both the transitions probabilities between the states and the probabilties of each step of belonging to each of the states. 

The algoritm uses: 

- a predefined distribution with prior parameters (guesses)

- a dataset of step lengths

- a predefined number of states

#### a) Priors parameters
Here we first explore (using **), the ranges of each of the parameters for each distributions. We are going to run 1000 combinations between each of the ranges, for each of the models.  

```{r, echo=FALSE}
rangosDist <- list("gamma" = list("mean" = c(0.1, 20), "sd" = c(0.1,20)), 
                   "weibull" = list("shape" = c(0, 2.7), "scale" = c(0.1,15)),  ##segun el articulo
                   "lnorm" =  list("location" = c(-1, 20), "scale" = c(0.001,3)))

DF_rangos <- data.frame("value" = c("min", "max"))
DF_rangos <- cbind(DF_rangos, as.data.frame(rangosDist))
DF_rangos
```

These limits were adjusted looking at the general distribution of the steps lengths (see previous figure). For the gamma mean and sd, we check the maximum possible values to include the 120 meters steps. For the weibull, the maximum shape was considering the left-skew and the scale was consider to include the 120 m steps. For lnorm, the location was varied to mimic **, and the scale was varied accordingly to include all the steps. It is important to note that these are only priors guesses, and the real parameters can outbound these limits. The utility of sweeping these priors is to avoid local likelihood maximums (or negative likelihoods minimums). 

#### b) States, models and whole loop

After this decision, we predefined 2 states and load the database. We ran the models for 1000 combinations of priors, 3 distributions for the step lengths (gamma, lnorm and weibull). For each model we register the minimun likelihood and the minimum AIC (both values should be equivalent, since all the models have the same number of parameters). 

```{r, echo=FALSE}
DF_TOTAL <- data.frame("model"= 0, 
            "prior_par0_st1_st2"= 0,
            "prior_par1_st1_st2" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0,
           "st2_par0"=0,
           "st2_par1"= 0)

repetitions <- seq(1, 1000,1)
runModel <- "no"
if (runModel == "yes"){
for (modelStep in c("weibull", "gamma", "lnorm")){
  print(modelStep)
  rangePar0 <- runif(100000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])
  rangePar1 <- runif(100000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2])
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE),
              sample(rangePar0,1, replace= TRUE)) # step mean (two parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE), 
              sample(rangePar1,1, replace= TRUE)) 
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 2 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha$mod$minimum
    AIC_model <- AIC(m_cosecha)
    
    DF_TEMP <- data.frame("model"= modelStep, 
                          "prior_par0_st1_st2"= paste(par0[1], "_", par0[2]), 
                          "prior_par1_st1_st2"=  paste(par1[1], "_", par1[2]),
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha$mle$stepPar[1,1],
                          "st1_par1"= m_cosecha$mle$stepPar[2,1],
                          "st2_par0"= m_cosecha$mle$stepPar[1,2],
                          "st2_par1"= m_cosecha$mle$stepPar[2,2])
    
                      
    DF_TOTAL <- rbind(DF_TOTAL, DF_TEMP)    
    
    
      }
}

DF_TOTAL <- DF_TOTAL%>%
  filter(model != 0)
}
#write_csv(DF_TOTAL, "../output/wholeTable_1000_rep_0_20.csv")
```

We plot the different AIC values for all the models and combinations of parameters: 

```{r, echo=FALSE}
DF_TOTAL_1000 <- read.csv("../output/wholeTable_1000_rep_0_20.csv")
DF_TOTAL_1000 <- DF_TOTAL_1000 %>%
  separate(prior_par0_st1_st2, c("prior_par0_st1", "prior_par0_st2"), sep= "_", remove = TRUE) %>%
  separate(prior_par1_st1_st2, c("prior_par1_st1", "prior_par1_st2"), sep= "_", remove = TRUE)

DF_TOTAL_1000$prior_par0_st1 <- as.numeric(DF_TOTAL_1000$prior_par0_st1)
DF_TOTAL_1000$prior_par1_st1 <- as.numeric(DF_TOTAL_1000$prior_par1_st1)
DF_TOTAL_1000$prior_par0_st2 <- as.numeric(DF_TOTAL_1000$prior_par0_st2)
DF_TOTAL_1000$prior_par1_st2 <- as.numeric(DF_TOTAL_1000$prior_par1_st2)


FIG_AIC_model <- DF_TOTAL_1000 %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_jitter(aes(x= model, y= AIC_model, shape= model, fill= model), size= 4)+
  #scale_fill_manual(values = colorsGris) +
  scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_AIC_model
```

From this figure we note that in every model, almost all model generate 1 or 2 AIC values, but in the case of the gamma and lnorm distributions we can see some specific outliers that have minimal AIC values (less than 4500). Before taking these models for granted we decided to explore its resulting parameters and biological meaning. 

We filter the priors and resulting parameters for these outliers: 

```{r, echo=FALSE}
DF_1000_OUTLIERS <- DF_TOTAL_1000 %>%
  filter(AIC_model <=4500)
DF_1000_OUTLIERS[,seq(2,11,1)] <- round(DF_1000_OUTLIERS[,seq(2,11,1)], 2)

DF_1000_OUTLIERS
```

If we focus on the generated states (st1_par0, st1_par1, st2_par0 and st2_par1) we note that:

- for the gamma distributions, all the models suggest almost the same parameters for both states**invert states

- State 1.gamma(mean [5-9.22], sd[3.25-8.81]). This is a state that will characterize almost all steps. 

- state 2: gamma(mean[2-4], sd[0])- A state that only considers the 2 to 4 m steps, with no variance. 

- For the lnorm distribution, the two states are equivalent

state 2 lnorm (location[1.37-1.43], shape[0.66])-a state that **
- state 1: lnorm([1.5-1.6], shape:0). 

If we observe (using the viterbi algoritm) how these model divide the trajectories:

```{r, echo=FALSE}

DF_1000_OUTLIERS<- DF_1000_OUTLIERS %>%
  mutate(contador = 1)%>%
  group_by(model) %>%
  mutate(countModel = cumsum(contador))

OUTLIERS_EX <- DF_1000_OUTLIERS %>%
  filter(countModel == 1)

modelos_OUTLIERS <- list("gamma" = 0, 
     "gamma" = 0,  ##segun el articulo
     "lnorm" =  0)

for (i in seq(1, dim(OUTLIERS_EX)[1],1)){
  par0_p <- as.numeric(c(OUTLIERS_EX$prior_par0_st1[i], OUTLIERS_EX$prior_par0_st2[i]))
  par1_p <- as.numeric(c(OUTLIERS_EX$prior_par1_st1[i], OUTLIERS_EX$prior_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  print(stepPar0_p)
  #op1
  m_cosecha_OUT<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(OUTLIERS_EX$model[i]))
  modelos_OUTLIERS[[as.character(OUTLIERS_EX$model[i])]] <- m_cosecha_OUT 
}

print("dei")

```

For the gamma distribution (we show an example with 2 trajectories)
```{r, fig.show='hold', out.width="50%", echo= FALSE}
plot(modelos_OUTLIERS$gamma, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

For the lnorm distribution (we show an example with 2 trajectories)
```{r, fig.show='hold', out.width="50%", echo=FALSE}
plot(modelos_OUTLIERS$lnorm, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

As we can see, the algorithm considers one state for the really small steps  (<4 m) and other state for all the other step lengths. This is interesting but it doe not makes sense to assume on distribution without any variance. In this sense, we assume that it makes sense to remove these outliers. 

If we plot the AIC figures without the outliers we have: 
```{r, echo=FALSE}
FIG_AIC_model_sin <- DF_TOTAL_1000 %>% 
  filter(AIC_model != "Inf")%>% 
  filter(AIC_model > 4500)%>%
  ggplot(aes(x= model, y= AIC_model))+
  geom_jitter(aes(x= model, y= AIC_model, shape= model, fill= model), size= 4)+
  #scale_fill_manual(values = colorsGris) +
  scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()

FIG_AIC_model_sin
```

We observe some minimum values per model, that we are going to use. 

```{r}
DF_TOTAL_MIN <- DF_TOTAL_1000 %>%
  filter(AIC_model > 4500)%>%
  group_by(model)%>%
  filter(AIC_model == min(AIC_model))
```

```{r}


modelos_p <- list("gamma" = 0, 
     "weibull" = 0,  ##segun el articulo
     "lnorm" =  0)

for (i in seq(1,dim(DF_TOTAL_MIN)[1],1)){
  par0_p <- as.numeric(c(DF_TOTAL_MIN$prior_par0_st1[i], DF_TOTAL_MIN$prior_par0_st2[i]))
  par1_p <- as.numeric(c(DF_TOTAL_MIN$prior_par1_st1[i], DF_TOTAL_MIN$prior_par1_st2[i]))
  stepPar0_p <- c(par0_p, par1_p)
  print(stepPar0_p)
  #op1
  m_cosecha_p<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(DF_TOTAL_MIN$model[i]))
  modelos_p[[as.character(DF_TOTAL_MIN$model[i])]] <- m_cosecha_p 
}


```


```{r, fig.show='hold', out.width="50%"}
plot(modelos_p$gamma, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

```{r, fig.show='hold', out.width="50%"}
plot(modelos_p$lnorm, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```

```{r, fig.show='hold', out.width="50%"}
plot(modelos_p$weibull, animals = c("I_Car12", "H_Fran9"), ask = FALSE, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```





```{r}
FIG_AIC_model <- DF_TOTAL %>% 
  filter(AIC_model != "Inf")%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_boxplot(aes(fill= model))+
  geom_jitter(aes(x= model, y= AIC_model), col= "darkred")+
  scale_fill_manual(values = colorsGris) +
  theme_bw()

#ggsave(FIG_AIC_model,filename=paste("../output/", "FIG_AIC_MODEL_100", ".png", sep=""),  height = 5, width = 16) # ID will be the unique identifier. and change the extension from .png to whatever you like (eps, pdf etc)

FIG_AIC_model_sinOut <- DF_TOTAL %>% 
  filter(AIC_model != "Inf")%>% 
  filter(AIC_model >4000)%>% 
  ggplot(aes(x= model, y= AIC_model))+
  geom_boxplot(aes(fill= model), width = 0.2)+
  geom_jitter(aes(x= model, y= AIC_model), col= "darkred", width = 0.1)+
  scale_fill_manual(values = colorsGris)+
  theme_bw()

#ggsave(FIG_AIC_model_sinOut,filename=paste("../output/", "FIG_AIC_100_SINOUT_MODEL", ".png", sep=""),  height = 5, width = 16) # ID will be the unique identifier. and change the extension from .png to whatever you like (eps, pdf etc)

```

