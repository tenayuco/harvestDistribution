---
title: "Supplementary Material 1. HMM analysis from: Harvesting trajectories in large-scale coffee plantations: ecological and managment drivers and implications"
author: "Mora Van Cauwelaert et al., 2023"
output:
  pdf_document: default
bibliography: movehmm.bib
---


## 0. Introduction to State-space models with HMM


State space models coupled with hidden Markov models (HMMs) are models in which the distribution that generates an observation $Z_t$ depends on the state $S_t$ of an underlying and unobserved Markov process (Fig.1) [@zucchini2016hidden]. In this sense, the observations $Z_t$ can be retrieved from one to multiple distributions related to the number of states. In the context of animal movement, the state $S_t$ is interpreted as a proxy for the behavioral state of the animal (e.g. foraging, exploring; [@michelot2016movehmm]). The observations $Zt$ are bivariate time series ($Zt = (l_t, \phi_t)$) where $l_t$ is the step length (the Euclidean distance) and $\phi_t$ the turning angle, between two succesive locations [@michelot2019movehmm, @zucchini2016hidden]. Biologically speaking, these models try to include the process where the movement of agents (e.g. short or large steps) depends on its behavior. With these models, we can define the different originary distributions and then decode the most likely sequence of states along the trajectory of an agent, its average time within a state, and the number of switches between states.  

![Process generating the observations in a two-state HMM. The chain followed the path 2, 1, 1, 1, 2, 1, as indicated on the left. The corresponding state-dependent distributions are shown in the middle. The observations are generated from the corresponding active distributions. Taken from (Zucchini, 2016)](hmmFullfigure.png){width=50%}



Here we used the _movehmm_ library (@michelot2019movehmm) to i) fit the most likely distributions to the harvester movement data in each farm, ii) describe the different states and iii) decode and compare the sequence of states in the two farms (Ecological and Conventional) with the Viterbi algorithm. 

\newpage

## 1. Fitting of HMM

### 1.1. Preparation of data

We loaded _ggplot2_, _dplyr_, _tidyverse_ and _movehmm_ libraries. We then loaded the data of the trajectories and did some punctual modifications to it. We had in total 12 trajectories, with ($x, y$) coordinates (Fig. 2).

```{r, message=FALSE, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(moveHMM)
library(knitr)
library(reshape2)
mycols <- c("#021128","#1b4a64", "#3585a0", "#759580", "#c78f34", "#fd9706","#fdb81c","#fbdb30")

groupColors2 <- c("#021128", "#fd9706")
mycols3c <-c("#759580", "#1b4a64")
```


```{r, echo=FALSE, message=FALSE}

#load the data
WP_COSECHA_UTM_SP <- read.csv("../data/cleanData_wayPointsCoffee_UTM.csv", stringsAsFactors = FALSE )

#punctual modifications
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  mutate(finca = replace(finca, finca == "Ecological", "E")) %>%
  mutate(finca = replace(finca, finca == "Conventional", "C"))


  
#WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
 # filter(finca == mode)



#normalization of UTM
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>% rowwise() %>% 
  group_by(finca, ID_POR_FINCA, pante)%>% 
  mutate(xNorm = x_UTM - min(x_UTM)) %>%
  mutate(yNorm = y_UTM - min(y_UTM))

#now the precision (not the accuracy) of the GPS goes to 5 decimal points (lat y lot) and this is equivalent to ~1m
#so we can round the xNorm and y yNorm
WP_COSECHA_UTM_SP$xNorm <- round(WP_COSECHA_UTM_SP$xNorm, 0)
WP_COSECHA_UTM_SP$yNorm <- round(WP_COSECHA_UTM_SP$yNorm, 0)


#we remove some spurious data were delta = 0
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  filter(delta !=0)%>%
  unite("Finca_ID", finca, ID_POR_FINCA, remove = TRUE)

#we create this ID column to prepare the data for movehmm
WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP %>%
  dplyr::select("ID" = Finca_ID, xNorm, yNorm)

#we remove the pante information as it is not relevant for the analysis
WP_COSECHA_UTM_SP_PRE$pante <- NULL
```





```{r echo=FALSE, warning=FALSE, fig.cap= "12 trajectories of harvesters for both farms (E: Ecological, C: conventional). Each green dot represent a tree" , fig.height= 12, fig.width=10}

mapHarvest_total<- WP_COSECHA_UTM_SP_PRE %>% 
  ggplot(aes(x= xNorm, y = yNorm)) +
  geom_path(aes(), size= 1)+
  geom_point(size=1, col= "black", shape= 21,fill= "darkgreen")+ 
  scale_color_manual(values= mycols3c)+
  facet_wrap(~ ID, ncol=3)+
  theme(panel.spacing = unit(0.8, "lines"), text = element_text(size = 15))+
  theme_bw()+
  labs(x= "X", y= "Y", col= "Farm")

mapHarvest_total
```


A first assumption for the analysis was made: we took these time irregular trajectories (where each point represents one different tree, but where the time between two trees is variable) and treated them as a regular trajectories. This aimed to analyze the change in the movement of the workers during a day, generated by the underlying pattern of trees or by the differences in the fruit charge and ripening synchronicity. We convert this database into a _movehmm_ object where the step distance $l_t$ and the relative angle $\phi_t$ between the $(x, y)$ coordinates is calculated (table 1). Now, for the following analysis, we only took the step distance and treated both farms as one. We decided to exclude the angles because they didn't have a biological meaning for irregular trajectories. The input for the analysis is then the histogram presented in Fig. 3. The values of the steps lengths ranges from 1 to 117, with a mean of 5.14 and a median equal to 4. 

```{r include=FALSE}


WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP_PRE %>%
  separate(ID, into= c("Finca", "IDperFinca"), remove= FALSE)

```


\newpage

### 1.2. Fitting of the data

The algorithm of the _movehmm_ library uses:

a) a predefined number of states. Here we will use two. But the algorithm also explores the case when both states are equal. 

b) a defined family of distributions. Here we will try to fit two different exponential families (_gamma_ and _weibull_).

c) prior parameters for each of the distributions, for each state.  

d) The observations (step-lengths) (the data of harvesters)

With these inputs, the algorithm extracts the most likely two-state-distributions with their respective parameters (within the predefined family of distributions) from the data. During the fitting process, the algorithm uses the maximum-log likelihood and the _forward algorithm_ (a recursive algorithm starting with the prior distributions; [@zucchini2016hidden]). We ran a loop to fit the data to two different families (_weibull_, and _gamma_) and in order to avoid local maximal likelihoods, we swapped 100 combinations across a range of prior parameters for each model [@michelot2019movehmm]. For the _gamma_ distribution, the minimum and maximum values of each range were chosen to encompass the full distribution (including values below and over the mean). For the _weibull_ distribution, the maximum shape considered the left-skew shape and the scale was chosen to include the 120m long steps (see the ranges in table 2). Many of these combinations of prior parameters converged to the same final distributions.  

```{r, echo=FALSE}
rangosDist <- list("gamma" = list("mean" = c(0.1, 10), "sd" = c(0.1,10)), 
                   "weibull" = list("shape" = c(0.1, 2.7), "scale" = c(0.1,15))  ##segun el articulo
                   )

DF_rangos <- data.frame("value" = c("min", "max"))
DF_rangos <- cbind(DF_rangos, as.data.frame(rangosDist))
kable(DF_rangos, caption = "Minimun and maximum values of the prior parameters for each distribution")
```
analisi doble
```{r, echo=FALSE}
#  we create the movehmm object

for (mode in c("E", "C")){
  
WP_COSECHA_UTM_SP_PRE_F <- WP_COSECHA_UTM_SP_PRE %>% filter (Finca == as.character(mode))
WP_COSECHA_UTM_SP_PRE_F$Finca <- NULL
WP_COSECHA_UTM_SP_PRE_F$IDperFinca <- NULL

dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE_F, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros

write_csv(dataCosecha, paste("../output/dataCosecha_PorFinca",as.character(mode), ".csv", sep = "_"))



dataCosechaRes <- dataCosecha %>%
  summarise(MeanSizeStep = mean(step), SDSizeStepp = sd(step))

DF_TOTAL <- data.frame("model"= 0, 
            "prior_par0_st1_st2"= 0,
            "prior_par1_st1_st2" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0,
           "st2_par0"=0,
           "st2_par1"= 0)

repetitions <- seq(1, 1000,1)
runModel <- "no"
if (runModel == "yes"){
for (modelStep in c("weibull", "gamma")){
  print(modelStep)
  rangePar0 <- runif(1000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])
  rangePar1 <- runif(1000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2])
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE),
              sample(rangePar0,1, replace= TRUE)) # step mean (two parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE), 
              sample(rangePar1,1, replace= TRUE)) 
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 2 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha$mod$minimum
    AIC_model <- AIC(m_cosecha)
    
    DF_TEMP <- data.frame("model"= modelStep, 
                          "prior_par0_st1_st2"= paste(par0[1], "_", par0[2]), 
                          "prior_par1_st1_st2"=  paste(par1[1], "_", par1[2]),
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha$mle$stepPar[1,1],
                          "st1_par1"= m_cosecha$mle$stepPar[2,1],
                          "st2_par0"= m_cosecha$mle$stepPar[1,2],
                          "st2_par1"= m_cosecha$mle$stepPar[2,2])
    
                      
    DF_TOTAL <- rbind(DF_TOTAL, DF_TEMP)    
    
    
      }
}

DF_TOTAL <- DF_TOTAL%>%
  filter(model != 0)

#write_csv(DF_TOTAL, paste("../output/wholeTable_100repsPorFinca",as.character(mode), ".csv", sep = "_"))
}




}

```

simple
```{r, echo=FALSE}

for (mode in c("E", "C")){
  
WP_COSECHA_UTM_SP_PRE_F <- WP_COSECHA_UTM_SP_PRE %>% filter (Finca == as.character(mode))
WP_COSECHA_UTM_SP_PRE_F$Finca <- NULL
WP_COSECHA_UTM_SP_PRE_F$IDperFinca <- NULL

dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE_F, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros


DF_TOTAL_ONESTATE <- data.frame("model"= 0, 
            "prior_par0_st1"= 0,
            "prior_par1_st1" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0)

repetitions <- seq(1, 1000,1)
runModelSimple <- "no"
if (runModelSimple == "yes"){
for (modelStep in c("weibull", "gamma")){
  print(modelStep)
  rangePar0 <- runif(1000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])  #corre 100000 valores en el rango del parametro 0
  rangePar1 <- runif(1000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2]) #corre 100000 valores en el rango del parametro 1
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE)) # step mean (one parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE))
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha_oneState<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 1 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha_oneState$mod$minimum
    AIC_model <- AIC(m_cosecha_oneState)
    
    DF_TEMP_ONESTATE <- data.frame("model"= modelStep, 
                          "prior_par0_st1"= par0[1], 
                          "prior_par1_st1"= par1[1],
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha_oneState$mle$stepPar[1],
                          "st1_par1"= m_cosecha_oneState$mle$stepPar[2])
    
                      
    DF_TOTAL_ONESTATE <- rbind(DF_TOTAL_ONESTATE, DF_TEMP_ONESTATE)    
    
    
      }
}

DF_TOTAL_ONESTATE <- DF_TOTAL_ONESTATE%>%
  filter(model != 0)
#write_csv(DF_TOTAL_ONESTATE, paste("../output/wholeTableONESTATE_porFinca_100rep",as.character(mode), ".csv", sep = "_"))

}

}
```


ahora estos son los resultados (sin vlver a correr todo)



```{r, echo=FALSE}

#here we load the simulation with the 100 combinations
#DF_TOTAL_1000 <- read.csv("../output/wholeTable_100_rep_0_20_E_.csv")

DF_TOTAL_2states_E <- read.csv("../output/wholeTable_100repsPorFinca_E_.csv")
DF_TOTAL_2states_C <- read.csv("../output/wholeTable_100repsPorFinca_C_.csv")
DF_TOTAL_1state_E <- read.csv("../output/wholeTableONESTATE_porFinca_100rep_E_.csv")
DF_TOTAL_1state_C <- read.csv("../output/wholeTableONESTATE_porFinca_100rep_C_.csv")

#aqui headear cada una para el pdf#

##pero ahora quitar los priors que no interesan tanto

DF_TOTAL_2states_C$farm <- "C"
DF_TOTAL_2states_E$farm <- "E"

DF_TOTAL_2states <- rbind(DF_TOTAL_2states_C, DF_TOTAL_2states_E)


DF_TOTAL_1state_C$farm <- "C"
DF_TOTAL_1state_E$farm <- "E"

DF_TOTAL_1state <- rbind(DF_TOTAL_1state_C, DF_TOTAL_1state_E)

rm(DF_TOTAL_1state_C)
rm(DF_TOTAL_1state_E)
rm(DF_TOTAL_2states_C)
rm(DF_TOTAL_2states_E)


#we spplit the priors parameters in table of 2 states

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  separate(prior_par0_st1_st2, c("prior_par0_st1", "prior_par0_st2"), sep= "_", remove = TRUE) %>%
  separate(prior_par1_st1_st2, c("prior_par1_st1", "prior_par1_st2"), sep= "_", remove = TRUE)

DF_TOTAL_2states$prior_par0_st1 <- as.numeric(DF_TOTAL_2states$prior_par0_st1)
DF_TOTAL_2states$prior_par1_st1 <- as.numeric(DF_TOTAL_2states$prior_par1_st1)
DF_TOTAL_2states$prior_par0_st2 <- as.numeric(DF_TOTAL_2states$prior_par0_st2)
DF_TOTAL_2states$prior_par1_st2 <- as.numeric(DF_TOTAL_2states$prior_par1_st2)

DF_TOTAL_2states[,seq(2,11,1)] <- round(DF_TOTAL_2states[,seq(2,11,1)], 2)


##aca hacemos filtro s de outliers

DF_TOTAL_1state <- DF_TOTAL_1state %>%
  filter(st1_par1 >0.00001)

DF_TOTAL_1state <- DF_TOTAL_1state %>%
  filter(! (model == "weibull"& st1_par0>3 ))

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(! (model == "gamma"& st1_par0>120)) 


############
DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(st1_par1 >0.00001) %>%
  filter(st2_par1 >0.00001) 

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(! (model == "weibull"& (st1_par0>3 | st2_par0>3)))

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(! (model == "gamma"& (st1_par0>120 | st2_par0>120)))  #aqui quito esos gamma rraros


###





DF_TOTAL_1state$prior_par0_st2 <- NA
DF_TOTAL_1state$prior_par1_st2 <- NA
DF_TOTAL_1state$st2_par0 <- NA
DF_TOTAL_1state$st2_par1 <- NA

DF_TOTAL_1state$states<- 1
DF_TOTAL_2states$states <- 2


DF_TOTAL <- rbind(DF_TOTAL_1state, DF_TOTAL_2states)

```



```{r, echo=FALSE}


##vamos a qiotar gran AIC
DF_TOTAL_SIN <- DF_TOTAL %>%
  filter(AIC_model != "Inf")



      

```

Some combinations resulted in distributions with zero variance. We decided to remove those cases as they did not make any biological sense. We also removed states with means higher than the ranges, for visualization (this does not change the results as they had maximal AIC that would be removed anyways). We then plotted the minimum negative log of the likelihood without these outliers (Fig.4). The minimum negative log-likelihood is equivalent to the maximum likelihood [@zucchini2016hidden]. Almost all the combinations of prior parameters converge to two models with equivalent minimum likelihood for both distributions (Fig. 4). In this sense, the parameters of the models with minimal likelihoods are robust to the initial parameters. In particular gamma distribution resulted in models with a lower min neg likelihood (and lower AIC as show in table 3.)

We also explored the differences in the estimated parameters between the resulting states and their AIC. This corroborates that the models with the minimal AIC have two clearly distinct states (purples dots in Fig. 5). Besides, we ran all the analysis with one-state distributions for both families and compared them with our two-state distribution models using the minimal AIC (table 3). As we note in table 3, two-state distribution have the minimal AIC, and particularly with the gamma family. 


```{r, fig.cap= "Minimun Negative Log-likelihood per combination of prior parameters for two different distributions", echo=FALSE, fig.height= 3, fig.width=5}
FIG_MIN_LIKE <- DF_TOTAL_SIN %>% 
  ggplot()+
  geom_jitter(aes(x= model, y= AIC_model, shape= model, fill= model), size= 3)+
  scale_fill_manual(values = c("#AAAAAA", "#FFFFFF")) +
  #scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()+
  facet_grid(farm~states)+
  labs(x= "Distribution", y= "AIC", shape= "Distribution", fill= "Distribution")
FIG_MIN_LIKE
```





```{r, echo=FALSE}

#here we extract the values with minimal AIC for both distributions, and we add a filter t only extract one of the cases!!!
DF_TOTAL_MIN <- DF_TOTAL_SIN %>%
  group_by(model, states, farm)%>%
  filter(AIC_model == min(AIC_model)) %>%
  group_by(model, states, AIC_model, farm) %>%
  mutate(conteo = 1)%>%
  mutate(contador= cumsum(conteo))%>%
  filter(contador ==1)

DF_TOTAL_MIN$conteo <- NULL
DF_TOTAL_MIN$contador <- NULL

kable(DF_TOTAL_MIN, caption = "Best models for each of the distributions. We added the prior parameters, the likelihood, AIC criteria and the final parameters. pr:prior, st1: state 1, p1: parameter 1 (shape for weibull and mean for gamma, p2: parameter 2 (scale for weibull and sd for gamma).")


write.csv(DF_TOTAL_MIN, "../output/DF_TOTAL_AIC_porFincas.csv")


```



\newpage

## 2. Description of the states, for each studied distribution.

We plotted the two state distributions for _gamma_ and _weibull_ families with the obtained final parameters (see figure. 6 and table 4). For both families, one of the states produced a distribution that encompass most of the highly frequent short steps and falls abruptly for size steps bigger than 13 m. The other state generates a long tailed distribution with a lower probability of short steps (compared to the other distribution) and a non zero probability for steps bigger than 13 m (Fig. 6 and table 4). This results show that from the movement of the harvesters (observations $Z_t$) we can extract two hidden markov states ($S_t$). The first state generate distributions with short steps (we can interpret this as harvesting the closest tree) and the second state generate longer steps (when the worker has to move to another part of the plot). This second state is highly unlikely (3.7% of steps in gamma distribution, 5.2% for weibull). Now, for the following analysis, we took only the gamma distribution as it presented a lower AIC.

```{r}
DF_TOTAL_MIN_2 <- DF_TOTAL_MIN %>% 
  filter(model == "gamma")%>% 
  filter(states == 2)
```


###AUI VOY
```{r, echo=FALSE, message=FALSE}

modelos <- list("C" = 0, "E"= 0)  ##segun el articulo

for (mode in c("C", "E")){
  
WP_COSECHA_UTM_SP_PRE_F <- WP_COSECHA_UTM_SP_PRE %>% filter (Finca == as.character(mode))
WP_COSECHA_UTM_SP_PRE_F$Finca <- NULL
WP_COSECHA_UTM_SP_PRE_F$IDperFinca <- NULL

dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE_F, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros

DF_TOTAL_MIN_2_F <- DF_TOTAL_MIN_2 %>%filter (farm == as.character(mode))

#modelos_p <- list("gamma" = 0, 
#     "weibull" = 0)

modelos_p <- list("gamma" = 0)

par0_p <- as.numeric(c(DF_TOTAL_MIN_2_F$prior_par0_st1, DF_TOTAL_MIN_2_F$prior_par0_st2))
par1_p <- as.numeric(c(DF_TOTAL_MIN_2_F$prior_par1_st1, DF_TOTAL_MIN_2_F$prior_par1_st2))


  stepPar0_p <- c(par0_p, par1_p)
  #print(stepPar0_p)
  #op1
  m_cosecha_p<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(DF_TOTAL_MIN_2$model))
  modelos_p[[as.character(DF_TOTAL_MIN_2$model[i])]] <- m_cosecha_p 


dataCosecha_V <- dataCosecha
dataCosecha_V$state <- viterbi(modelos_p$gamma)

dataCosecha_V <- dataCosecha_V %>%
  mutate(conteo = 1)%>%
  group_by(ID) %>%
  mutate(contador = cumsum(conteo))
  
write.csv(dataCosecha_V, paste("../data/analyzedData_figuresFINCA", as.character(mode),".csv", sep = "_"))

modelos[as.character(mode)] <- modelos_p ##segun el articulo

}

```


```{r echo=FALSE, fig.cap="Distribution of states $St$ along two trajectories. Each color follow the code of colors of Fig.6 for the gamma distribution)", fig.keep=c(3,4), fig.show='hold', message=FALSE, out.width="50%"}

#plotStates(modelos_p$gamma, ask = F, animals = c( "H_Fran9", "I_Car12"))

plot(modelos$C, ask = F, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```


```{r echo=FALSE, fig.cap="Distribution of states $St$ along two trajectories. Each color follow the code of colors of Fig.6 for the gamma distribution)", fig.keep=c(3,4), fig.show='hold', message=FALSE, out.width="50%"}

#plotStates(modelos_p$gamma, ask = F, animals = c( "H_Fran9", "I_Car12"))

plot(modelos$E, ask = F, plotTracks = TRUE, breaks = 100, col = groupColors2, lwd=3.0)
```




\newpage

## 3. Sequence of states and relation with the farms.

With the Viterbi algorithm, the package _movehmm_ decodes the most likely sequence of states (assuming a markov chain) and the transitions matrix between hidden states. This takes into account the conditional probabilities between the observations and hidden states $P(Z_t|S_t))$ [@zucchini2016hidden]. In this sense, _movehmm_ can estimate the state with the highest probability for each step but this might not be the same as the state in the most probable sequence returned by the Viterbi algorithm (Fig. 8, second and third row vs first row). This is because the Viterbi algorithm performs “global decoding”, whereas the state probabilities are “local decoding”[@zucchini2016hidden, @michelot2019movehmm].

```{r echo=FALSE, fig.cap="State probabilities for each step of E_6 trajectory and result of the Viterbi algorithm", fig.height= 4, fig.width=5, message=FALSE}
plotStates(modelos_p$gamma, animals ="E_6", ask = F)
```


We finally plotted the sequence of the most likely states along each of the trajectories (Fig. 9) and estimate the probability of the most unlikely state (state 1, that represent the relocalization of the workers in the plot)- according to the farm the trajectory belonged to (Fig. 10). We note that the percentage of steps from state 1 correlates with the identity of the farm (Fig. 10): 4 out of 6 trajectories that belong to the Ecological Farm, presented a higher than the mean percentage of longer steps, compared to the Conventional Farm, where 5 out of 6 were below the mean. (__note__: in the main text the number of the states was inverted for practicality)).

```{r echo=FALSE, fig.cap="Sequence of states along the trajectory in two different farms (C: Conventional, E: Ecological)", fig.height=4, fig.width=10}





#https://cran.r-project.org/web/packages/moveHMM/vignettes/moveHMM-guide.pdf

#https://theomichelot.github.io/software/


#https://statisticsbyjim.com/probability/weibull-distribution/

```


\newpage

## 4. References





