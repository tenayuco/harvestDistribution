---
title: "Supplementary Material 1. HMM analysis from: Harvesting trajectories in large-scale coffee plantations: ecological and managment drivers and implications"
author: "Mora Van Cauwelaert et al., 2023"
output:
  pdf_document: default
bibliography: movehmm.bib
csl: agriculture-ecosystems-and-environment.csl
---


## 0. Introduction to State-space models with HMM


State space models coupled with hidden Markov models (HMMs) are models in which the distribution that generates an observation $Z_t$ depends on the state $S_t$ of an underlying and unobserved Markov process (Fig.1) [@zucchini2016hidden]. In this sense, the observations $Z_t$ can be retrieved from one to multiple distributions related to the number of states. In the context of animal movement, the state $S_t$ is interpreted as a proxy for the behavioral state of the animal (e.g. foraging, exploring; [@michelot2016movehmm]). The observations $Zt$ are bivariate time series ($Zt = (l_t, \phi_t)$) where $l_t$ is the step length (the Euclidean distance) and $\phi_t$ the turning angle, between two succesive locations [@zucchini2016hidden]. Biologically speaking, these models try to include the process where the movement of agents (e.g. short or large steps) depends on its behavior [@patterson2008state]. With these models, we can define the different originary distributions and then decode the most likely sequence of states along the trajectory of an agent, its average time within a state, and the number of switches between states.  

![Process generating the observations in a two-state HMM. The chain followed the path 2, 1, 1, 1, 2, 1, as indicated on the left. The corresponding state-dependent distributions are shown in the middle. The observations are generated from the corresponding active distributions. Taken from (Zucchini, 2016)](hmmFullfigure.png){width=50%}



Here we used the _movehmm_ library [@michelot2019movehmm] to i) fit the most likely distributions to the harvester movement data in each plantation, ii) decode and compare the sequence of states in the two plantations (Ecological and Conventional) with the Viterbi algorithm. To see the full results and visualizations please refer to main text.

\newpage

## 1. Preparation of data and algorithm

### 1.1. Preparation of data

We loaded _ggplot2_, _dplyr_, _tidyverse_ and _movehmm_ libraries. We then loaded the data of the trajectories and did some punctual modifications to it. We had in total 12 trajectories, with ($x, y$) coordinates (see Fig. 2).

```{r, message=FALSE, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(moveHMM)
library(knitr)
library(reshape2)
mycols <- c("#021128","#1b4a64", "#3585a0", "#759580", "#c78f34", "#fd9706","#fdb81c","#fbdb30")

groupColors2 <- c("#021128", "#fd9706")
mycols3c <-c("#759580", "#1b4a64")
```


```{r, echo=FALSE, message=FALSE}

#load the data
WP_COSECHA_UTM_SP <- read.csv("../data/cleanData_wayPointsCoffee_UTM.csv", stringsAsFactors = FALSE )

#punctual modifications
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  mutate(finca = replace(finca, finca == "Ecological", "O")) %>%
  mutate(finca = replace(finca, finca == "Conventional", "C"))


  
#WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
 # filter(finca == mode)



#normalization of UTM
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>% rowwise() %>% 
  group_by(finca, ID_POR_FINCA, pante)%>% 
  mutate(xNorm = x_UTM - min(x_UTM)) %>%
  mutate(yNorm = y_UTM - min(y_UTM))

#now the precision (not the accuracy) of the GPS goes to 5 decimal points (lat y lot) and this is equivalent to ~1m
#so we can round the xNorm and y yNorm
WP_COSECHA_UTM_SP$xNorm <- round(WP_COSECHA_UTM_SP$xNorm, 0)
WP_COSECHA_UTM_SP$yNorm <- round(WP_COSECHA_UTM_SP$yNorm, 0)


#we remove some spurious data were delta = 0
WP_COSECHA_UTM_SP <- WP_COSECHA_UTM_SP %>%
  filter(delta !=0)%>%
  unite("Finca_ID", finca, ID_POR_FINCA, remove = TRUE)

#we create this ID column to prepare the data for movehmm
WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP %>%
  dplyr::select("ID" = Finca_ID, xNorm, yNorm)

#we remove the pante information as it is not relevant for the analysis
WP_COSECHA_UTM_SP_PRE$pante <- NULL
```





```{r echo=FALSE, warning=FALSE, fig.cap= "Trajectories of harvesters for both plantations (O: organic, C: conventional). Each green dot represent a tree" , fig.height= 12, fig.width=10}

mapHarvest_total<- WP_COSECHA_UTM_SP_PRE %>% 
  ggplot(aes(x= xNorm, y = yNorm)) +
  geom_path(aes(), size= 1)+
  geom_point(size=1, col= "black", shape= 21,fill= "darkgreen")+ 
  scale_color_manual(values= mycols3c)+
  facet_wrap(~ ID, ncol=3)+
  theme(panel.spacing = unit(0.8, "lines"), text = element_text(size = 15))+
  theme_bw()+
  labs(x= "X", y= "Y", col= "Farm")

mapHarvest_total
```


We took these time irregular trajectories (where each point represents one different tree, but where the time between two trees is variable) and treated them as regular trajectories. This aimed to analyze the change in the movement of the workers during a day, generated by the underlying pattern of trees or by the differences in the fruit charge and ripening synchronicity. We convert this database into a _movehmm_ object where the step distance $l_t$ and the relative angle $\phi_t$ between the $(x, y)$ coordinates is calculated. Now, for the following analysis, we only took the step distance and treated each plantation separately. We decided to exclude the angles because they didn't have a biological meaning for irregular trajectories. 

```{r include=FALSE}


WP_COSECHA_UTM_SP_PRE <- WP_COSECHA_UTM_SP_PRE %>%
  separate(ID, into= c("Finca", "IDperFinca"), remove= FALSE)

```


### 1.2. Fitting algoritm

The algorithm of the _movehmm_ library uses:

a) a predefined number of states. Here we will use one and two. 

b) a defined family of distributions. Here we will try to fit two different exponential families (_gamma_ and _weibull_).

c) prior parameters for each of the distributions, for each state.  

d) The observations (step-lengths) (the data of harvesters)

With these inputs, the algorithm extracts the most likely two-state and one-state distributions with their respective parameters (within the predefined family of distributions) from the data. During the fitting process, the algorithm uses the maximum-log likelihood and the _forward algorithm_ (a recursive algorithm starting with the prior distributions; [@zucchini2016hidden]). We ran a loop across 1000 prior parameters within the range shown in Table 1 to fit the data to two different families (_weibull_ and _gamma_) and to avoid local maximal likelihoods [@michelot2019movehmm]. For the _gamma_ distribution, the minimum and maximum values of each prior parameter range were chosen to encompass the full distribution (including values below and over the mean). For the _weibull_ distribution, the maximum shape considered the left-skew shape and the scale was chosen to include the 120m long steps (Table 1). Many of these combinations of prior parameters converged to the same final distributions.  

```{r, echo=FALSE}
rangosDist <- list("gamma" = list("mean" = c(0.1, 10), "sd" = c(0.1,10)), 
                   "weibull" = list("shape" = c(0.1, 2.7), "scale" = c(0.1,15))  ##segun el articulo
                   )

DF_rangos <- data.frame("value" = c("min", "max"))
DF_rangos <- cbind(DF_rangos, as.data.frame(rangosDist))
kable(DF_rangos, caption = "Minimun and maximum values of the prior parameters for each distribution")
```


### 1.3. Outputs

We first ran the model for each plantation (Organic and Conventional) assuming two-state distributions.The output is stored in /output/dataFrameAnalysis/. 
```{r, echo=FALSE}
#  we create the movehmm object

for (mode in c("O", "C")){
  
WP_COSECHA_UTM_SP_PRE_F <- WP_COSECHA_UTM_SP_PRE %>% filter (Finca == as.character(mode))
WP_COSECHA_UTM_SP_PRE_F$Finca <- NULL
WP_COSECHA_UTM_SP_PRE_F$IDperFinca <- NULL

dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE_F, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros

write_csv(dataCosecha, paste("../output/dataFramesGenerated/dataCosecha_PorFinca",as.character(mode), ".csv", sep = "_"))

dataCosechaRes <- dataCosecha %>%
  summarise(MeanSizeStep = mean(step), SDSizeStepp = sd(step))

write_csv(dataCosechaRes, paste("../output/dataFramesGenerated/dataCosechaRES_PorFinca",as.character(mode), ".csv", sep = "_"))

DF_TOTAL <- data.frame("model"= 0, 
            "prior_par0_st1_st2"= 0,
            "prior_par1_st1_st2" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0,
           "st2_par0"=0,
           "st2_par1"= 0)

#if you want to run the model change runModel to yes

repetitions <- seq(1, 1000,1)
runModel <- "no"
if (runModel == "yes"){
for (modelStep in c("weibull", "gamma")){
  print(modelStep)
  rangePar0 <- runif(1000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])
  rangePar1 <- runif(1000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2])
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE),
              sample(rangePar0,1, replace= TRUE)) # step mean (two parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE), 
              sample(rangePar1,1, replace= TRUE)) 
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    #print(par0)
    #print(par1)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 2 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha$mod$minimum
    AIC_model <- AIC(m_cosecha)
    
    DF_TEMP <- data.frame("model"= modelStep, 
                          "prior_par0_st1_st2"= paste(par0[1], "_", par0[2]), 
                          "prior_par1_st1_st2"=  paste(par1[1], "_", par1[2]),
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha$mle$stepPar[1,1],
                          "st1_par1"= m_cosecha$mle$stepPar[2,1],
                          "st2_par0"= m_cosecha$mle$stepPar[1,2],
                          "st2_par1"= m_cosecha$mle$stepPar[2,2])
    
                      
    DF_TOTAL <- rbind(DF_TOTAL, DF_TEMP)    
    
    
      }
}

DF_TOTAL <- DF_TOTAL%>%
  filter(model != 0)

write_csv(DF_TOTAL, paste("../output/dataFrameAnalysis/wholeTable_1000repsPorFinca",as.character(mode), ".csv", sep = "_"))
}

}

```

We then ran the model for each plantation (Organic and Conventional) assuming one-state distributions. The output is stored in /output/dataFrameAnalysis/
```{r, echo=FALSE}

for (mode in c("O", "C")){
  
WP_COSECHA_UTM_SP_PRE_F <- WP_COSECHA_UTM_SP_PRE %>% filter (Finca == as.character(mode))
WP_COSECHA_UTM_SP_PRE_F$Finca <- NULL
WP_COSECHA_UTM_SP_PRE_F$IDperFinca <- NULL

dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE_F, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros


DF_TOTAL_ONESTATE <- data.frame("model"= 0, 
            "prior_par0_st1"= 0,
            "prior_par1_st1" = 0,
           "minNegLike" = 0,
           "AIC_model" = 0,
           "st1_par0"= 0,
           "st1_par1"=0)

repetitions <- seq(1, 1000,1)
runModelSimple <- "no"
if (runModelSimple == "yes"){
for (modelStep in c("weibull", "gamma")){
  print(modelStep)
  rangePar0 <- runif(1000, rangosDist[[modelStep]][[1]][1], rangosDist[[modelStep]][[1]][2])  #corre 100000 valores en el rango del parametro 0
  rangePar1 <- runif(1000, rangosDist[[modelStep]][[2]][1], rangosDist[[modelStep]][[2]][2]) #corre 100000 valores en el rango del parametro 1
  for (rep in repetitions){
    par0 <- c(sample(rangePar0,1, replace= TRUE)) # step mean (one parameters: one for each state)
    par1 <- c(sample(rangePar1,1, replace= TRUE))
    par0 <- round(par0, 4)
    par1 <- round(par1, 4)
    stepPar <- c(par0,par1)
  #op1
    tryCatch({
    m_cosecha_oneState<- fitHMM(data = dataCosecha, stepDist = modelStep,  
                       nbStates = 1 , stepPar0 = stepPar, angleDist = "none")
    },
    error=function(cond){
      print("error de parametros")
      print(stepPar)
      message(cond)
    }
    )
    
    minNegLike <-  m_cosecha_oneState$mod$minimum
    AIC_model <- AIC(m_cosecha_oneState)
    
    DF_TEMP_ONESTATE <- data.frame("model"= modelStep, 
                          "prior_par0_st1"= par0[1], 
                          "prior_par1_st1"= par1[1],
                          "minNegLike" = minNegLike,
                          "AIC_model" = AIC_model,
                          "st1_par0"= m_cosecha_oneState$mle$stepPar[1],
                          "st1_par1"= m_cosecha_oneState$mle$stepPar[2])
    
                      
    DF_TOTAL_ONESTATE <- rbind(DF_TOTAL_ONESTATE, DF_TEMP_ONESTATE)    
    
      }
}

DF_TOTAL_ONESTATE <- DF_TOTAL_ONESTATE%>%
  filter(model != 0)
#write_csv(DF_TOTAL_ONESTATE, paste("../output/wholeTableONESTATE_porFinca_100rep",as.character(mode), ".csv", sep = "_"))

}

}
```

## 2. Results

### 2.1 Two-state and one-state fitting


Some combinations resulted in distributions with zero variance. We decided to remove those cases as they did not make any biological sense. We also removed states with means higher than the ranges (this does not change the results as they had maximal AIC that would be removed anyways). We then plotted the AIC without these outliers (Fig.3). Almost all the combinations of prior parameters converge to two models with equivalent AIC for both distributions (Fig. 3). In this sense, the parameters of the models are robust to the initial prior parameters chosen. Two-state gamma distributions had the minimal AIC. The minimal AIC for each family and number of states are represented in Table 2 and stored in: output/dataFramesGenerated/



```{r, echo=FALSE}

#here we load the simulation with the 100 combinations
#DF_TOTAL_1000 <- read.csv("../output/wholeTable_100_rep_0_20_E_.csv")

DF_TOTAL_2states_O <- read.csv("../output/dataFrameAnalysis/wholeTable_100repsPorFinca_O_.csv")
DF_TOTAL_2states_C <- read.csv("../output/dataFrameAnalysis/wholeTable_100repsPorFinca_C_.csv")
DF_TOTAL_1state_O <- read.csv("../output/dataFrameAnalysis/wholeTableONESTATE_porFinca_100rep_O_.csv")
DF_TOTAL_1state_C <- read.csv("../output/dataFrameAnalysis/wholeTableONESTATE_porFinca_100rep_C_.csv")

#aqui headear cada una para el pdf#

##pero ahora quitar los priors que no interesan tanto

DF_TOTAL_2states_C$farm <- "C"
DF_TOTAL_2states_O$farm <- "O"

DF_TOTAL_2states <- rbind(DF_TOTAL_2states_C, DF_TOTAL_2states_O)

DF_TOTAL_1state_C$farm <- "C"
DF_TOTAL_1state_O$farm <- "O"

DF_TOTAL_1state <- rbind(DF_TOTAL_1state_C, DF_TOTAL_1state_O)

rm(DF_TOTAL_1state_C)
rm(DF_TOTAL_1state_O)
rm(DF_TOTAL_2states_C)
rm(DF_TOTAL_2states_O)

#we spplit the priors parameters in table of 2 states

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  separate(prior_par0_st1_st2, c("prior_par0_st1", "prior_par0_st2"), sep= "_", remove = TRUE) %>%
  separate(prior_par1_st1_st2, c("prior_par1_st1", "prior_par1_st2"), sep= "_", remove = TRUE)

DF_TOTAL_2states$prior_par0_st1 <- as.numeric(DF_TOTAL_2states$prior_par0_st1)
DF_TOTAL_2states$prior_par1_st1 <- as.numeric(DF_TOTAL_2states$prior_par1_st1)
DF_TOTAL_2states$prior_par0_st2 <- as.numeric(DF_TOTAL_2states$prior_par0_st2)
DF_TOTAL_2states$prior_par1_st2 <- as.numeric(DF_TOTAL_2states$prior_par1_st2)

DF_TOTAL_2states[,seq(2,11,1)] <- round(DF_TOTAL_2states[,seq(2,11,1)], 2)


##We remove the values that had no variance, the values that had weibull shape over 3, and gamma mean bigger e the maximum range. 

DF_TOTAL_1state <- DF_TOTAL_1state %>%
  filter(st1_par1 >0.00001)

DF_TOTAL_1state <- DF_TOTAL_1state %>%
  filter(! (model == "weibull"& st1_par0>3 ))

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(! (model == "gamma"& st1_par0>120)) 


############

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(st1_par1 >0.00001) %>%
  filter(st2_par1 >0.00001) 

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(! (model == "weibull"& (st1_par0>3 | st2_par0>3)))

DF_TOTAL_2states <- DF_TOTAL_2states %>%
  filter(! (model == "gamma"& (st1_par0>120 | st2_par0>120)))  #aqui quito esos gamma rraros


###we complete the data frame


DF_TOTAL_1state$prior_par0_st2 <- NA
DF_TOTAL_1state$prior_par1_st2 <- NA
DF_TOTAL_1state$st2_par0 <- NA
DF_TOTAL_1state$st2_par1 <- NA

DF_TOTAL_1state$states<- 1
DF_TOTAL_2states$states <- 2


DF_TOTAL <- rbind(DF_TOTAL_1state, DF_TOTAL_2states)



```


```{r, echo=FALSE}

# we remove the values with infite AIC
##vamos a qiotar gran AIC
DF_TOTAL_SIN <- DF_TOTAL %>%
  filter(AIC_model != "Inf")
```


```{r, fig.cap= "Minimun AIC per combination of prior parameters for two different distributions, for 1 and 2 states, for each of the plantations. O:Organic, C: Conventional", echo=FALSE, fig.height= 5, fig.width=7}
FIG_MIN_LIKE <- DF_TOTAL_SIN %>% 
 # mutate(farm = replace(farm, farm == "E", "O")) %>%
  ggplot()+
  geom_jitter(aes(x= model, y= AIC_model, shape= model, fill= model), size= 3)+
  scale_fill_manual(values = c("#AAAAAA", "#FFFFFF")) +
  #scale_fill_manual(values = groupColors3) +
  scale_shape_manual(values = c(21, 24, 22))+
  theme_bw()+
  facet_grid(farm~states)+
  theme(plot.title = element_text(hjust = 0.5))+
  labs(x= "Distribution", y= "AIC", shape= "Distribution", fill= "Distribution", title= "Number of states")
FIG_MIN_LIKE
```





```{r, echo=FALSE, message=FALSE, comment=FALSE}

#here we extract the values with minimal AIC for both distributions, and we add a filter t only extract one of the cases!!!
DF_TOTAL_MIN <- DF_TOTAL_SIN %>%
  group_by(model, states, farm)%>%
  filter(AIC_model == min(AIC_model)) %>%
  group_by(model, states, AIC_model, farm) %>%
  mutate(conteo = 1)%>%
  mutate(contador= cumsum(conteo))%>%
  filter(contador ==1)

DF_TOTAL_MIN$conteo <- NULL
DF_TOTAL_MIN$contador <- NULL

DF_TOTAL_MIN[,seq(2,7,1)] <- round(DF_TOTAL_MIN[,seq(2,7,1)], 2)

library(kableExtra)

#kable(iris[1:5,],
 #     format = "latex", booktabs = TRUE) %>%
#  kableExtra::landscape()

kable(DF_TOTAL_MIN, caption = "Best models for each of the distributions. We added the prior parameters, the min negative likelihood, AIC criteria and the final parameters. pr:prior, st1: state 1, p1: parameter 1 (shape for weibull and mean for gamma), p2: parameter 2 (scale for weibull and sd for gamma).") %>%
  kableExtra::landscape() %>%
  kable_styling(font_size = 8)



write.csv(DF_TOTAL_MIN, "../output/dataFramesGenerated/DF_TOTAL_AIC_porFincas.csv")


```


\newpage

### 2.2 Sequence of states for each plantation (two states gamma distribution)

In the following analysis we only used the two-states gamma distribution as it had the lower AIC. For each plantation we assigned each step to "state 1" or "state 2" according to the Viterbi algorithm. The output tables used for the plotting the results are exported to data/

```{r, echo=FALSE, message=FALSE}
DF_TOTAL_MIN_2 <- DF_TOTAL_MIN %>% 
  filter(model == "gamma")%>% 
  filter(states == 2)
```

```{r, echo=FALSE, message=FALSE}

modelos <- list("C" = 0, "O"= 0)  ##segun el articulo

for (mode in c("C", "O")){
  
WP_COSECHA_UTM_SP_PRE_F <- WP_COSECHA_UTM_SP_PRE %>% filter (Finca == as.character(mode))
WP_COSECHA_UTM_SP_PRE_F$Finca <- NULL
WP_COSECHA_UTM_SP_PRE_F$IDperFinca <- NULL

dataCosecha <- prepData(WP_COSECHA_UTM_SP_PRE_F, type= "UTM", coordNames = c("xNorm", "yNorm"))

#we remove the steps equal to zero (when the worker harvest 2 trees separated by less than a meter..)
dataCosecha <- dataCosecha %>% 
  filter(step!= 0)  #we remove the zeros

DF_TOTAL_MIN_2_F <- DF_TOTAL_MIN_2 %>%filter (farm == as.character(mode))

#modelos_p <- list("gamma" = 0, 
#     "weibull" = 0)

#modelos_p <- list("gamma" = 0)

par0_p <- as.numeric(c(DF_TOTAL_MIN_2_F$prior_par0_st1, DF_TOTAL_MIN_2_F$prior_par0_st2))
par1_p <- as.numeric(c(DF_TOTAL_MIN_2_F$prior_par1_st1, DF_TOTAL_MIN_2_F$prior_par1_st2))


  stepPar0_p <- c(par0_p, par1_p)
  #print(stepPar0_p)
  #op1
  m_cosecha_p<- fitHMM(data = dataCosecha, nbStates = 2 , stepPar0 = stepPar0_p, angleDist = "none", stepDist = as.character(DF_TOTAL_MIN_2_F$model))
 # modelos_p[[as.character(DF_TOTAL_MIN_2$model[i])]] <- m_cosecha_p 

modelos[[as.character(mode)]] <- m_cosecha_p ##segun el articulo es imporatnte el doble corchete para que meta toda lalista


dataCosecha_V <- dataCosecha
dataCosecha_V$state <- viterbi(m_cosecha_p)

dataCosecha_V <- dataCosecha_V %>%
  mutate(conteo = 1)%>%
  group_by(ID) %>%
  mutate(contador = cumsum(conteo))
  
write.csv(dataCosecha_V, paste("../data/analyzedData_figuresFINCA", as.character(mode),".csv", sep = "_"))


}

```

With the Viterbi algorithm, the package _movehmm_ decodes the most likely sequence of states (assuming a markov chain) and the transitions matrix between hidden states. This takes into account the conditional probabilities between the observations and hidden states $P(Z_t|S_t))$ [@zucchini2016hidden] (Fig. 4 and 5). In this sense, _movehmm_ can estimate the state with the highest probability for each step but this might not be the same as the state in the most probable sequence returned by the Viterbi algorithm (Fig. 4 and 5, second and third row vs first row). This is because the Viterbi algorithm performs “global decoding”, whereas the state probabilities are “local decoding” [@zucchini2016hidden]. In the main text we plot the result of the Viterbi algoritm for each of the algoritms.


```{r echo=FALSE, message=FALSE}
plotStates_mod <- function (m, animals = NULL, ask = TRUE) 
{
   # if (!is.moveHMM(m)) 
    #    stop("'m' must be a moveHMM object (as output by fitHMM)")
    nbAnimals <- length(unique(m$data$ID))
    nbStates <- ncol(m$mle$stepPar)
    if (nbStates == 1) 
        stop("Only one state.")
    cat("Decoding states sequence... ")
    states <- viterbi(m)
    cat("DONE\n")
    cat("Computing states probabilities... ")
    sp <- stateProbs(m)
    cat("DONE\n")
    if (is.null(animals)) 
        animalsInd <- 1:nbAnimals
    else {
        if (is.character(animals)) {
            animalsInd <- NULL
            for (zoo in 1:length(animals)) {
                if (length(which(unique(m$data$ID) == animals[zoo])) == 
                  0) 
                  stop("Check animals argument.")
                animalsInd <- c(animalsInd, which(unique(m$data$ID) == 
                  animals[zoo]))
            }
        }
        if (is.numeric(animals)) {
            if (length(which(animals < 1)) > 0 | length(which(animals > 
                nbAnimals)) > 0) 
                stop("Check animals argument.")
            animalsInd <- animals
        }
    }
    par(mfrow = c(nbStates + 1, 1))
    par(ask = ask)
    for (zoo in animalsInd) {
        ind <- which(m$data$ID == unique(m$data$ID)[zoo])
        par(mar = c(5, 4, 4, 2) - c(2, 0, 0, 0))
        plot(states[ind], main = paste("Harvester ID: ", unique(m$data$ID)[zoo], 
            sep = ""), ylim = c(0.5, nbStates + 0.5), yaxt = "n", 
            xlab = "", ylab = "State")
        axis(side = 2, at = 1:nbStates, labels = as.character(1:nbStates))
        par(mar = c(5, 4, 4, 2) - c(0, 0, 2, 0))
        for (i in 1:nbStates) {
            plot(sp[ind, i], type = "l", xlab = "Observation index", 
                ylab = paste("Pr(State=", i, ")", sep = ""))
            abline(h = 0.5, lty = 2, col = "darkgrey")
        }
    }
    par(mar = c(5, 4, 4, 2) + 0.1)
    par(mfrow = c(1, 1))
    par(ask = FALSE)
}
```


```{r echo=FALSE, fig.cap="State probabilities for each step of harvester C_1 trajectory and result of the Viterbi algorithm", fig.height= 4, fig.width=5, message=FALSE}
plotStates_mod(modelos$C, animals ="C_1", ask = F)
```

```{r echo=FALSE, fig.cap="State probabilities for each step of harvester O_1 trajectory and result of the Viterbi algorithm", fig.height= 4, fig.width=5, message=FALSE}
plotStates_mod(modelos$O, animals ="O_1", ask = F)
```





\newpage



## 4. References






